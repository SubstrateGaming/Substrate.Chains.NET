//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Substrate.Zeitgeist.NET.NetApiExt.Generated.Storage
{
    
    
    /// <summary>
    /// >> TokensStorage
    /// </summary>
    public sealed class TokensStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> TokensStorage Constructor
        /// </summary>
        public TokensStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Tokens", "TotalIssuance"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset), typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Tokens", "Locks"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset>), typeof(Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.bounded.bounded_vec.BoundedVecT30)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Tokens", "Accounts"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset>), typeof(Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.orml_tokens.AccountData)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("Tokens", "Reserves"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset>), typeof(Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.bounded.bounded_vec.BoundedVecT31)));
        }
        
        /// <summary>
        /// >> TotalIssuanceParams
        ///  The total issuance of a token type.
        /// </summary>
        public static string TotalIssuanceParams(Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset key)
        {
            return RequestGenerator.GetStorage("Tokens", "TotalIssuance", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> TotalIssuanceDefault
        /// Default value as hex string
        /// </summary>
        public static string TotalIssuanceDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> TotalIssuance
        ///  The total issuance of a token type.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> TotalIssuance(Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset key, string blockhash, CancellationToken token)
        {
            string parameters = TokensStorage.TotalIssuanceParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> LocksParams
        ///  Any liquidity locks of a token type under an account.
        ///  NOTE: Should only be accessed when setting, changing and freeing a lock.
        /// </summary>
        public static string LocksParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset> key)
        {
            return RequestGenerator.GetStorage("Tokens", "Locks", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> LocksDefault
        /// Default value as hex string
        /// </summary>
        public static string LocksDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Locks
        ///  Any liquidity locks of a token type under an account.
        ///  NOTE: Should only be accessed when setting, changing and freeing a lock.
        /// </summary>
        public async Task<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.bounded.bounded_vec.BoundedVecT30> Locks(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset> key, string blockhash, CancellationToken token)
        {
            string parameters = TokensStorage.LocksParams(key);
            var result = await _client.GetStorageAsync<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.bounded.bounded_vec.BoundedVecT30>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AccountsParams
        ///  The balance of a token type under an account.
        /// 
        ///  NOTE: If the total is ever zero, decrease account ref account.
        /// 
        ///  NOTE: This is only used in the case that this module is used to store
        ///  balances.
        /// </summary>
        public static string AccountsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset> key)
        {
            return RequestGenerator.GetStorage("Tokens", "Accounts", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> AccountsDefault
        /// Default value as hex string
        /// </summary>
        public static string AccountsDefault()
        {
            return "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000" +
                "00000000000000000";
        }
        
        /// <summary>
        /// >> Accounts
        ///  The balance of a token type under an account.
        /// 
        ///  NOTE: If the total is ever zero, decrease account ref account.
        /// 
        ///  NOTE: This is only used in the case that this module is used to store
        ///  balances.
        /// </summary>
        public async Task<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.orml_tokens.AccountData> Accounts(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset> key, string blockhash, CancellationToken token)
        {
            string parameters = TokensStorage.AccountsParams(key);
            var result = await _client.GetStorageAsync<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.orml_tokens.AccountData>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ReservesParams
        ///  Named reserves on some account balances.
        /// </summary>
        public static string ReservesParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset> key)
        {
            return RequestGenerator.GetStorage("Tokens", "Reserves", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> ReservesDefault
        /// Default value as hex string
        /// </summary>
        public static string ReservesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Reserves
        ///  Named reserves on some account balances.
        /// </summary>
        public async Task<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.bounded.bounded_vec.BoundedVecT31> Reserves(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset> key, string blockhash, CancellationToken token)
        {
            string parameters = TokensStorage.ReservesParams(key);
            var result = await _client.GetStorageAsync<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.bounded.bounded_vec.BoundedVecT31>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> TokensCalls
    /// </summary>
    public sealed class TokensCalls
    {
    }
    
    /// <summary>
    /// >> TokensConstants
    /// </summary>
    public sealed class TokensConstants
    {
        
        /// <summary>
        /// >> MaxLocks
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxLocks()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x32000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxReserves
        ///  The maximum number of named reserves that can exist on an account.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxReserves()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x32000000");
            return result;
        }
    }
    
    /// <summary>
    /// >> TokensErrors
    /// </summary>
    public enum TokensErrors
    {
        
        /// <summary>
        /// >> BalanceTooLow
        /// The balance is too low
        /// </summary>
        BalanceTooLow,
        
        /// <summary>
        /// >> AmountIntoBalanceFailed
        /// Cannot convert Amount into Balance type
        /// </summary>
        AmountIntoBalanceFailed,
        
        /// <summary>
        /// >> LiquidityRestrictions
        /// Failed because liquidity restrictions due to locking
        /// </summary>
        LiquidityRestrictions,
        
        /// <summary>
        /// >> MaxLocksExceeded
        /// Failed because the maximum locks was exceeded
        /// </summary>
        MaxLocksExceeded,
        
        /// <summary>
        /// >> KeepAlive
        /// Transfer/payment would kill account
        /// </summary>
        KeepAlive,
        
        /// <summary>
        /// >> ExistentialDeposit
        /// Value too low to create account due to existential deposit
        /// </summary>
        ExistentialDeposit,
        
        /// <summary>
        /// >> DeadAccount
        /// Beneficiary account must pre-exist
        /// </summary>
        DeadAccount,
        
        /// <summary>
        /// >> TooManyReserves
        /// </summary>
        TooManyReserves,
    }
}
