//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Substrate.Zeitgeist.NET.NetApiExt.Generated.Storage
{
    
    
    /// <summary>
    /// >> NeoSwapsStorage
    /// </summary>
    public sealed class NeoSwapsStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> NeoSwapsStorage Constructor
        /// </summary>
        public NeoSwapsStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("NeoSwaps", "Pools"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U128), typeof(Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zrml_neo_swaps.types.pool.Pool)));
        }
        
        /// <summary>
        /// >> PoolsParams
        /// </summary>
        public static string PoolsParams(Substrate.NetApi.Model.Types.Primitive.U128 key)
        {
            return RequestGenerator.GetStorage("NeoSwaps", "Pools", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> PoolsDefault
        /// Default value as hex string
        /// </summary>
        public static string PoolsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Pools
        /// </summary>
        public async Task<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zrml_neo_swaps.types.pool.Pool> Pools(Substrate.NetApi.Model.Types.Primitive.U128 key, string blockhash, CancellationToken token)
        {
            string parameters = NeoSwapsStorage.PoolsParams(key);
            var result = await _client.GetStorageAsync<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zrml_neo_swaps.types.pool.Pool>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> NeoSwapsCalls
    /// </summary>
    public sealed class NeoSwapsCalls
    {
        
        /// <summary>
        /// >> buy
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Buy(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> market_id, Substrate.NetApi.Model.Types.Primitive.U16 asset_count, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset asset_out, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> amount_in, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> min_amount_out)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(market_id.Encode());
            byteArray.AddRange(asset_count.Encode());
            byteArray.AddRange(asset_out.Encode());
            byteArray.AddRange(amount_in.Encode());
            byteArray.AddRange(min_amount_out.Encode());
            return new Method(60, "NeoSwaps", 0, "buy", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> sell
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Sell(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> market_id, Substrate.NetApi.Model.Types.Primitive.U16 asset_count, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zeitgeist_primitives.asset.EnumAsset asset_in, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> amount_in, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> min_amount_out)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(market_id.Encode());
            byteArray.AddRange(asset_count.Encode());
            byteArray.AddRange(asset_in.Encode());
            byteArray.AddRange(amount_in.Encode());
            byteArray.AddRange(min_amount_out.Encode());
            return new Method(60, "NeoSwaps", 1, "sell", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> join
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Join(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> market_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> pool_shares_amount, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U128> max_amounts_in)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(market_id.Encode());
            byteArray.AddRange(pool_shares_amount.Encode());
            byteArray.AddRange(max_amounts_in.Encode());
            return new Method(60, "NeoSwaps", 2, "join", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> exit
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Exit(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> market_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> pool_shares_amount_out, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U128> min_amounts_out)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(market_id.Encode());
            byteArray.AddRange(pool_shares_amount_out.Encode());
            byteArray.AddRange(min_amounts_out.Encode());
            return new Method(60, "NeoSwaps", 3, "exit", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> withdraw_fees
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method WithdrawFees(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> market_id)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(market_id.Encode());
            return new Method(60, "NeoSwaps", 4, "withdraw_fees", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> deploy_pool
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method DeployPool(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> market_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> amount, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U128> spot_prices, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> swap_fee)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(market_id.Encode());
            byteArray.AddRange(amount.Encode());
            byteArray.AddRange(spot_prices.Encode());
            byteArray.AddRange(swap_fee.Encode());
            return new Method(60, "NeoSwaps", 5, "deploy_pool", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> NeoSwapsConstants
    /// </summary>
    public sealed class NeoSwapsConstants
    {
        
        /// <summary>
        /// >> MaxLiquidityTreeDepth
        ///  The maximum allowed liquidity tree depth per pool. Each pool can support `2^(depth + 1)
        ///  - 1` liquidity providers. **Must** be less than 16.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxLiquidityTreeDepth()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x09000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxSwapFee
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 MaxSwapFee()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x00CA9A3B000000000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> PalletId
        /// </summary>
        public Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.frame_support.PalletId PalletId()
        {
            var result = new Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.frame_support.PalletId();
            result.Create("0x7A67652F6E656F73");
            return result;
        }
    }
    
    /// <summary>
    /// >> NeoSwapsErrors
    /// </summary>
    public enum NeoSwapsErrors
    {
        
        /// <summary>
        /// >> AssetCountAboveMax
        /// The number of assets in the pool is above the allowed maximum.
        /// </summary>
        AssetCountAboveMax,
        
        /// <summary>
        /// >> AmountInAboveMax
        /// Amount paid is above the specified maximum.
        /// </summary>
        AmountInAboveMax,
        
        /// <summary>
        /// >> AmountOutBelowMin
        /// Amount received is below the specified minimum.
        /// </summary>
        AmountOutBelowMin,
        
        /// <summary>
        /// >> AssetNotFound
        /// Specified asset was not found in this pool.
        /// </summary>
        AssetNotFound,
        
        /// <summary>
        /// >> DuplicatePool
        /// Market already has an associated pool.
        /// </summary>
        DuplicatePool,
        
        /// <summary>
        /// >> IncorrectAssetCount
        /// Incorrect asset count.
        /// </summary>
        IncorrectAssetCount,
        
        /// <summary>
        /// >> IncorrectVecLen
        /// </summary>
        IncorrectVecLen,
        
        /// <summary>
        /// >> InsufficientPoolShares
        /// User doesn't own enough pool shares.
        /// </summary>
        InsufficientPoolShares,
        
        /// <summary>
        /// >> LiquidityTooLow
        /// The liquidity in the pool is too low.
        /// </summary>
        LiquidityTooLow,
        
        /// <summary>
        /// >> InvalidSpotPrices
        /// Sum of spot prices is not `1`.
        /// </summary>
        InvalidSpotPrices,
        
        /// <summary>
        /// >> InvalidTradingMechanism
        /// Market's trading mechanism is not LMSR.
        /// </summary>
        InvalidTradingMechanism,
        
        /// <summary>
        /// >> MarketNotActive
        /// Pool can only be traded on if the market is active.
        /// </summary>
        MarketNotActive,
        
        /// <summary>
        /// >> MathError
        /// Some calculation failed. This shouldn't happen.
        /// </summary>
        MathError,
        
        /// <summary>
        /// >> NotAllowed
        /// The user is not allowed to execute this command.
        /// </summary>
        NotAllowed,
        
        /// <summary>
        /// >> NotImplemented
        /// This feature is not yet implemented.
        /// </summary>
        NotImplemented,
        
        /// <summary>
        /// >> NumericalLimits
        /// Some value in the operation is too large or small.
        /// </summary>
        NumericalLimits,
        
        /// <summary>
        /// >> OutstandingFees
        /// Outstanding fees prevent liquidity withdrawal.
        /// </summary>
        OutstandingFees,
        
        /// <summary>
        /// >> PoolNotFound
        /// Specified market does not have a pool.
        /// </summary>
        PoolNotFound,
        
        /// <summary>
        /// >> SpotPriceAboveMax
        /// Spot price is above the allowed maximum.
        /// </summary>
        SpotPriceAboveMax,
        
        /// <summary>
        /// >> SpotPriceBelowMin
        /// Spot price is below the allowed minimum.
        /// </summary>
        SpotPriceBelowMin,
        
        /// <summary>
        /// >> SwapFeeAboveMax
        /// Pool's swap fee exceeds the allowed upper limit.
        /// </summary>
        SwapFeeAboveMax,
        
        /// <summary>
        /// >> SwapFeeBelowMin
        /// Pool's swap fee is below the allowed lower limit.
        /// </summary>
        SwapFeeBelowMin,
        
        /// <summary>
        /// >> Unexpected
        /// This shouldn't happen.
        /// </summary>
        Unexpected,
        
        /// <summary>
        /// >> ZeroAmount
        /// Specified monetary amount is zero.
        /// </summary>
        ZeroAmount,
        
        /// <summary>
        /// >> LiquidityTreeError
        /// An error occurred when handling the liquidty tree.
        /// </summary>
        LiquidityTreeError,
        
        /// <summary>
        /// >> MinRelativeLiquidityThresholdViolated
        /// The relative value of a new LP position is too low.
        /// </summary>
        MinRelativeLiquidityThresholdViolated,
    }
}
