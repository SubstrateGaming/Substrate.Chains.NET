//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Substrate.Zeitgeist.NET.NetApiExt.Generated.Storage
{
    
    
    /// <summary>
    /// >> LiquidityMiningStorage
    /// </summary>
    public sealed class LiquidityMiningStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> LiquidityMiningStorage Constructor
        /// </summary>
        public LiquidityMiningStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("LiquidityMining", "BlockBoughtShares"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("LiquidityMining", "BlockSoldShares"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("LiquidityMining", "OwnedValues"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zrml_liquidity_mining.owned_values_params.OwnedValuesParams)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("LiquidityMining", "PerBlockIncentive"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
        }
        
        /// <summary>
        /// >> BlockBoughtSharesParams
        ///  Shares bought in the current block being constructed. Automatically *erased* after each finalized block.
        /// </summary>
        public static string BlockBoughtSharesParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("LiquidityMining", "BlockBoughtShares", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> BlockBoughtSharesDefault
        /// Default value as hex string
        /// </summary>
        public static string BlockBoughtSharesDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> BlockBoughtShares
        ///  Shares bought in the current block being constructed. Automatically *erased* after each finalized block.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> BlockBoughtShares(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = LiquidityMiningStorage.BlockBoughtSharesParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> BlockSoldSharesParams
        ///  Shares sold in the current block being constructed. Automatically *erased* after each finalized block.
        /// </summary>
        public static string BlockSoldSharesParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("LiquidityMining", "BlockSoldShares", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> BlockSoldSharesDefault
        /// Default value as hex string
        /// </summary>
        public static string BlockSoldSharesDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> BlockSoldShares
        ///  Shares sold in the current block being constructed. Automatically *erased* after each finalized block.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> BlockSoldShares(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = LiquidityMiningStorage.BlockSoldSharesParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> OwnedValuesParams
        ///  Owned balances (not shares) that are going to be distributed as incentives. Automatically
        ///  *updated* after each finalized block.
        /// </summary>
        public static string OwnedValuesParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("LiquidityMining", "OwnedValues", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> OwnedValuesDefault
        /// Default value as hex string
        /// </summary>
        public static string OwnedValuesDefault()
        {
            return "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000" +
                "000000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> OwnedValues
        ///  Owned balances (not shares) that are going to be distributed as incentives. Automatically
        ///  *updated* after each finalized block.
        /// </summary>
        public async Task<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zrml_liquidity_mining.owned_values_params.OwnedValuesParams> OwnedValues(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = LiquidityMiningStorage.OwnedValuesParams(key);
            var result = await _client.GetStorageAsync<Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.zrml_liquidity_mining.owned_values_params.OwnedValuesParams>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> PerBlockIncentiveParams
        ///  Per block distribution. How much each block will distribute across bought shares.
        /// </summary>
        public static string PerBlockIncentiveParams()
        {
            return RequestGenerator.GetStorage("LiquidityMining", "PerBlockIncentive", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> PerBlockIncentiveDefault
        /// Default value as hex string
        /// </summary>
        public static string PerBlockIncentiveDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> PerBlockIncentive
        ///  Per block distribution. How much each block will distribute across bought shares.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> PerBlockIncentive(string blockhash, CancellationToken token)
        {
            string parameters = LiquidityMiningStorage.PerBlockIncentiveParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> LiquidityMiningCalls
    /// </summary>
    public sealed class LiquidityMiningCalls
    {
        
        /// <summary>
        /// >> set_per_block_distribution
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetPerBlockDistribution(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> per_block_distribution)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(per_block_distribution.Encode());
            return new Method(53, "LiquidityMining", 0, "set_per_block_distribution", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> LiquidityMiningConstants
    /// </summary>
    public sealed class LiquidityMiningConstants
    {
        
        /// <summary>
        /// >> PalletId
        /// </summary>
        public Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.frame_support.PalletId PalletId()
        {
            var result = new Substrate.Zeitgeist.NET.NetApiExt.Generated.Model.frame_support.PalletId();
            result.Create("0x7A67652F6C796D67");
            return result;
        }
    }
    
    /// <summary>
    /// >> LiquidityMiningErrors
    /// </summary>
    public enum LiquidityMiningErrors
    {
        
        /// <summary>
        /// >> FundDoesNotHaveEnoughBalance
        /// Pallet account does not have enough funds
        /// </summary>
        FundDoesNotHaveEnoughBalance,
    }
}
