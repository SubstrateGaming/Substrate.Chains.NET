//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Substrate.Enjin.NET.NetApiExt.Generated.Storage
{
    
    
    /// <summary>
    /// >> MultiTokensStorage
    /// </summary>
    public sealed class MultiTokensStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> MultiTokensStorage Constructor
        /// </summary>
        public MultiTokensStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "TokenAccounts"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_multi_tokens.features.token.types.TokenAccount)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "Collections"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U128), typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.Collection)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "Tokens"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128>), typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.token.Token)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "NextCollectionId"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "CollectionAccounts"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>), typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_multi_tokens.features.collection.types.CollectionAccount)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "Attributes"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT8>), typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.attribute.Attribute)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "AssetIdsByLocation"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.xcm.v3.multilocation.MultiLocation), typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.token.AssetId)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "Migrations"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT42), typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_core.frame.migrations.Migration)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "MigrationStatus"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_core.frame.migrations.EnumMigrationStage)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "ClaimableCollectionIds"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Identity}, typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160), typeof(Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT19)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "UnmintableTokenIds"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U64>), typeof(Substrate.NetApi.Model.Types.Primitive.U64)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("MultiTokens", "NativeCollectionIds"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, typeof(Substrate.NetApi.Model.Types.Primitive.U128), typeof(Substrate.NetApi.Model.Types.Primitive.U128)));
        }
        
        /// <summary>
        /// >> TokenAccountsParams
        ///  Accounts per token
        /// </summary>
        public static string TokenAccountsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("MultiTokens", "TokenAccounts", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> TokenAccountsDefault
        /// Default value as hex string
        /// </summary>
        public static string TokenAccountsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> TokenAccounts
        ///  Accounts per token
        /// </summary>
        public async Task<Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_multi_tokens.features.token.types.TokenAccount> TokenAccounts(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.TokenAccountsParams(key);
            var result = await _client.GetStorageAsync<Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_multi_tokens.features.token.types.TokenAccount>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CollectionsParams
        ///  The collections in existence and their ownership details.
        /// </summary>
        public static string CollectionsParams(Substrate.NetApi.Model.Types.Primitive.U128 key)
        {
            return RequestGenerator.GetStorage("MultiTokens", "Collections", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> CollectionsDefault
        /// Default value as hex string
        /// </summary>
        public static string CollectionsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Collections
        ///  The collections in existence and their ownership details.
        /// </summary>
        public async Task<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.Collection> Collections(Substrate.NetApi.Model.Types.Primitive.U128 key, string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.CollectionsParams(key);
            var result = await _client.GetStorageAsync<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.Collection>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> TokensParams
        ///  Tokens storage
        /// </summary>
        public static string TokensParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128> key)
        {
            return RequestGenerator.GetStorage("MultiTokens", "Tokens", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> TokensDefault
        /// Default value as hex string
        /// </summary>
        public static string TokensDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Tokens
        ///  Tokens storage
        /// </summary>
        public async Task<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.token.Token> Tokens(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U128> key, string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.TokensParams(key);
            var result = await _client.GetStorageAsync<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.token.Token>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> NextCollectionIdParams
        ///  Sequencer for collectionID generators.
        /// </summary>
        public static string NextCollectionIdParams()
        {
            return RequestGenerator.GetStorage("MultiTokens", "NextCollectionId", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> NextCollectionIdDefault
        /// Default value as hex string
        /// </summary>
        public static string NextCollectionIdDefault()
        {
            return "0x00000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> NextCollectionId
        ///  Sequencer for collectionID generators.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> NextCollectionId(string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.NextCollectionIdParams();
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> CollectionAccountsParams
        ///  Stores information for an account per collection
        /// </summary>
        public static string CollectionAccountsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> key)
        {
            return RequestGenerator.GetStorage("MultiTokens", "CollectionAccounts", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> CollectionAccountsDefault
        /// Default value as hex string
        /// </summary>
        public static string CollectionAccountsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> CollectionAccounts
        ///  Stores information for an account per collection
        /// </summary>
        public async Task<Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_multi_tokens.features.collection.types.CollectionAccount> CollectionAccounts(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> key, string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.CollectionAccountsParams(key);
            var result = await _client.GetStorageAsync<Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_multi_tokens.features.collection.types.CollectionAccount>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AttributesParams
        ///  Metadata of collections and tokens.
        /// </summary>
        public static string AttributesParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT8> key)
        {
            return RequestGenerator.GetStorage("MultiTokens", "Attributes", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, key.Value);
        }
        
        /// <summary>
        /// >> AttributesDefault
        /// Default value as hex string
        /// </summary>
        public static string AttributesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Attributes
        ///  Metadata of collections and tokens.
        /// </summary>
        public async Task<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.attribute.Attribute> Attributes(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT8> key, string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.AttributesParams(key);
            var result = await _client.GetStorageAsync<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.attribute.Attribute>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> AssetIdsByLocationParams
        ///  Map of Locations to AssetIds of Foreign Tokens
        /// </summary>
        public static string AssetIdsByLocationParams(Substrate.Enjin.NET.NetApiExt.Generated.Model.xcm.v3.multilocation.MultiLocation key)
        {
            return RequestGenerator.GetStorage("MultiTokens", "AssetIdsByLocation", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> AssetIdsByLocationDefault
        /// Default value as hex string
        /// </summary>
        public static string AssetIdsByLocationDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> AssetIdsByLocation
        ///  Map of Locations to AssetIds of Foreign Tokens
        /// </summary>
        public async Task<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.token.AssetId> AssetIdsByLocation(Substrate.Enjin.NET.NetApiExt.Generated.Model.xcm.v3.multilocation.MultiLocation key, string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.AssetIdsByLocationParams(key);
            var result = await _client.GetStorageAsync<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.token.AssetId>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MigrationsParams
        ///  Stores last iterated keys for migrations. Used by multi block migrations
        ///  to resume from the last iterated key.
        /// 
        ///  Key is the storage prefix, value is the status of migration and last iterated key, if any.
        ///  i.e `["MultiTokens", "TokenAccounts"] -> (collection_id, token_id, account_id)`
        /// </summary>
        public static string MigrationsParams(Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT42 key)
        {
            return RequestGenerator.GetStorage("MultiTokens", "Migrations", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> MigrationsDefault
        /// Default value as hex string
        /// </summary>
        public static string MigrationsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> Migrations
        ///  Stores last iterated keys for migrations. Used by multi block migrations
        ///  to resume from the last iterated key.
        /// 
        ///  Key is the storage prefix, value is the status of migration and last iterated key, if any.
        ///  i.e `["MultiTokens", "TokenAccounts"] -> (collection_id, token_id, account_id)`
        /// </summary>
        public async Task<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_core.frame.migrations.Migration> Migrations(Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT42 key, string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.MigrationsParams(key);
            var result = await _client.GetStorageAsync<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_core.frame.migrations.Migration>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> MigrationStatusParams
        ///  Status of the current multi-block migration
        /// </summary>
        public static string MigrationStatusParams()
        {
            return RequestGenerator.GetStorage("MultiTokens", "MigrationStatus", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> MigrationStatusDefault
        /// Default value as hex string
        /// </summary>
        public static string MigrationStatusDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> MigrationStatus
        ///  Status of the current multi-block migration
        /// </summary>
        public async Task<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_core.frame.migrations.EnumMigrationStage> MigrationStatus(string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.MigrationStatusParams();
            var result = await _client.GetStorageAsync<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_core.frame.migrations.EnumMigrationStage>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> ClaimableCollectionIdsParams
        ///  Stores data for an ethereum address
        /// </summary>
        public static string ClaimableCollectionIdsParams(Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160 key)
        {
            return RequestGenerator.GetStorage("MultiTokens", "ClaimableCollectionIds", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Identity}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> ClaimableCollectionIdsDefault
        /// Default value as hex string
        /// </summary>
        public static string ClaimableCollectionIdsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> ClaimableCollectionIds
        ///  Stores data for an ethereum address
        /// </summary>
        public async Task<Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT19> ClaimableCollectionIds(Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160 key, string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.ClaimableCollectionIdsParams(key);
            var result = await _client.GetStorageAsync<Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT19>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> UnmintableTokenIdsParams
        ///  These token ids can only be minted by calling `force_mint`. The second key is an ethereum
        ///  base token id, and the value is the highest token index that cannot be minted. All token
        ///  indexes start from 1, so effectively it blocks token indexes from 1 to the value.
        /// </summary>
        public static string UnmintableTokenIdsParams(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U64> key)
        {
            return RequestGenerator.GetStorage("MultiTokens", "UnmintableTokenIds", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat,
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, key.Value);
        }
        
        /// <summary>
        /// >> UnmintableTokenIdsDefault
        /// Default value as hex string
        /// </summary>
        public static string UnmintableTokenIdsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> UnmintableTokenIds
        ///  These token ids can only be minted by calling `force_mint`. The second key is an ethereum
        ///  base token id, and the value is the highest token index that cannot be minted. All token
        ///  indexes start from 1, so effectively it blocks token indexes from 1 to the value.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U64> UnmintableTokenIds(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U64> key, string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.UnmintableTokenIdsParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U64>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> NativeCollectionIdsParams
        ///  Map of ethereum collection id to the native collection id
        /// </summary>
        public static string NativeCollectionIdsParams(Substrate.NetApi.Model.Types.Primitive.U128 key)
        {
            return RequestGenerator.GetStorage("MultiTokens", "NativeCollectionIds", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.Twox64Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> NativeCollectionIdsDefault
        /// Default value as hex string
        /// </summary>
        public static string NativeCollectionIdsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> NativeCollectionIds
        ///  Map of ethereum collection id to the native collection id
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.U128> NativeCollectionIds(Substrate.NetApi.Model.Types.Primitive.U128 key, string blockhash, CancellationToken token)
        {
            string parameters = MultiTokensStorage.NativeCollectionIdsParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.U128>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> MultiTokensCalls
    /// </summary>
    public sealed class MultiTokensCalls
    {
        
        /// <summary>
        /// >> create_collection
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method CreateCollection(Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.DefaultCollectionDescriptor descriptor)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(descriptor.Encode());
            return new Method(253, "MultiTokens", 0, "create_collection", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> destroy_collection
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method DestroyCollection(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            return new Method(253, "MultiTokens", 1, "destroy_collection", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> mutate_collection
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method MutateCollection(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.DefaultCollectionMutation mutation)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(mutation.Encode());
            return new Method(253, "MultiTokens", 2, "mutate_collection", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> mutate_token
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method MutateToken(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> token_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.token.DefaultTokenMutation mutation)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(token_id.Encode());
            byteArray.AddRange(mutation.Encode());
            return new Method(253, "MultiTokens", 3, "mutate_token", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> mint
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Mint(Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress recipient, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.mint.EnumDefaultMintParams @params)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(recipient.Encode());
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(@params.Encode());
            return new Method(253, "MultiTokens", 4, "mint", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> burn
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Burn(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.burn.DefaultBurnParams @params)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(@params.Encode());
            return new Method(253, "MultiTokens", 5, "burn", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> transfer
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Transfer(Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress recipient, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.transfer.EnumDefaultTransferParams @params)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(recipient.Encode());
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(@params.Encode());
            return new Method(253, "MultiTokens", 6, "transfer", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> freeze
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Freeze(Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.types.Freeze info)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(info.Encode());
            return new Method(253, "MultiTokens", 7, "freeze", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> thaw
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method Thaw(Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.types.Freeze info)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(info.Encode());
            return new Method(253, "MultiTokens", 8, "thaw", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_attribute
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method SetAttribute(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> token_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT8 key, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT9 value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(token_id.Encode());
            byteArray.AddRange(key.Encode());
            byteArray.AddRange(value.Encode());
            return new Method(253, "MultiTokens", 9, "set_attribute", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_attribute
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method RemoveAttribute(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> token_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT8 key)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(token_id.Encode());
            byteArray.AddRange(key.Encode());
            return new Method(253, "MultiTokens", 10, "remove_attribute", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> remove_all_attributes
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method RemoveAllAttributes(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> token_id, Substrate.NetApi.Model.Types.Primitive.U32 attribute_count)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(token_id.Encode());
            byteArray.AddRange(attribute_count.Encode());
            return new Method(253, "MultiTokens", 11, "remove_all_attributes", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> batch_transfer
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method BatchTransfer(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT17 recipients)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(recipients.Encode());
            return new Method(253, "MultiTokens", 12, "batch_transfer", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> batch_mint
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method BatchMint(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT18 recipients)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(recipients.Encode());
            return new Method(253, "MultiTokens", 13, "batch_mint", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> batch_set_attribute
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method BatchSetAttribute(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> token_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT16 attributes)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(token_id.Encode());
            byteArray.AddRange(attributes.Encode());
            return new Method(253, "MultiTokens", 14, "batch_set_attribute", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> approve_collection
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ApproveCollection(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 @operator, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32> expiration)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(@operator.Encode());
            byteArray.AddRange(expiration.Encode());
            return new Method(253, "MultiTokens", 15, "approve_collection", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> unapprove_collection
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method UnapproveCollection(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 @operator)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(@operator.Encode());
            return new Method(253, "MultiTokens", 16, "unapprove_collection", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> approve_token
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ApproveToken(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> token_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 @operator, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> amount, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32> expiration, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> current_amount)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(token_id.Encode());
            byteArray.AddRange(@operator.Encode());
            byteArray.AddRange(amount.Encode());
            byteArray.AddRange(expiration.Encode());
            byteArray.AddRange(current_amount.Encode());
            return new Method(253, "MultiTokens", 17, "approve_token", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> unapprove_token
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method UnapproveToken(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> token_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 @operator)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(token_id.Encode());
            byteArray.AddRange(@operator.Encode());
            return new Method(253, "MultiTokens", 18, "unapprove_token", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> claim_collections
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ClaimCollections(Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 destination, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.ecdsa.Signature ethereum_signature, Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160 ethereum_address, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32> collection_count)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(destination.Encode());
            byteArray.AddRange(ethereum_signature.Encode());
            byteArray.AddRange(ethereum_address.Encode());
            byteArray.AddRange(collection_count.Encode());
            return new Method(253, "MultiTokens", 32, "claim_collections", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> claim_tokens
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ClaimTokens(Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 destination, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.ecdsa.Signature ethereum_signature, Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160 ethereum_address)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(destination.Encode());
            byteArray.AddRange(ethereum_signature.Encode());
            byteArray.AddRange(ethereum_address.Encode());
            return new Method(253, "MultiTokens", 33, "claim_tokens", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> finish_claim_tokens
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method FinishClaimTokens(Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 destination, Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160 ethereum_address)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(destination.Encode());
            byteArray.AddRange(ethereum_address.Encode());
            return new Method(253, "MultiTokens", 36, "finish_claim_tokens", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_mutate_collection
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceMutateCollection(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.DefaultCollectionMutation mutation)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(mutation.Encode());
            return new Method(253, "MultiTokens", 19, "force_mutate_collection", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_transfer
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceTransfer(Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress source, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress destination, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.transfer.EnumDefaultTransferParams @params)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(source.Encode());
            byteArray.AddRange(destination.Encode());
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(@params.Encode());
            return new Method(253, "MultiTokens", 20, "force_transfer", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_set_collection
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceSetCollection(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.Collection> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(value.Encode());
            return new Method(253, "MultiTokens", 21, "force_set_collection", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_set_token
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceSetToken(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> token_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.token.Token> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(token_id.Encode());
            byteArray.AddRange(value.Encode());
            return new Method(253, "MultiTokens", 22, "force_set_token", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_set_attribute
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceSetAttribute(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> token_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT8 key, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.attribute.Attribute> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(token_id.Encode());
            byteArray.AddRange(key.Encode());
            byteArray.AddRange(value.Encode());
            return new Method(253, "MultiTokens", 23, "force_set_attribute", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_set_collection_account
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceSetCollectionAccount(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress account_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_multi_tokens.features.collection.types.CollectionAccount> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(account_id.Encode());
            byteArray.AddRange(value.Encode());
            return new Method(253, "MultiTokens", 24, "force_set_collection_account", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_set_token_account
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceSetTokenAccount(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> token_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress account_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_multi_tokens.features.token.types.TokenAccount> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(token_id.Encode());
            byteArray.AddRange(account_id.Encode());
            byteArray.AddRange(value.Encode());
            return new Method(253, "MultiTokens", 25, "force_set_token_account", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_create_collection
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceCreateCollection(Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 owner, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.DefaultCollectionDescriptor descriptor)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(owner.Encode());
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(descriptor.Encode());
            return new Method(253, "MultiTokens", 26, "force_create_collection", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_mint
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceMint(Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress> caller, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress recipient, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.mint.EnumFlexibleMintParams @params, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress> depositor)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(caller.Encode());
            byteArray.AddRange(recipient.Encode());
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(@params.Encode());
            byteArray.AddRange(depositor.Encode());
            return new Method(253, "MultiTokens", 27, "force_mint", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_burn
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceBurn(Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress caller, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.burn.DefaultBurnParams @params)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(caller.Encode());
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(@params.Encode());
            return new Method(253, "MultiTokens", 28, "force_burn", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_approve_collection
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceApproveCollection(Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress caller, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 @operator, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32> expiration)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(caller.Encode());
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(@operator.Encode());
            byteArray.AddRange(expiration.Encode());
            return new Method(253, "MultiTokens", 29, "force_approve_collection", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_freeze
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceFreeze(Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.types.Freeze info)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(info.Encode());
            return new Method(253, "MultiTokens", 30, "force_freeze", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_set_next_collection_id
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceSetNextCollectionId(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(value.Encode());
            return new Method(253, "MultiTokens", 31, "force_set_next_collection_id", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_set_ethereum_account
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceSetEthereumAccount(Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160 address, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT19> value)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(address.Encode());
            byteArray.AddRange(value.Encode());
            return new Method(253, "MultiTokens", 34, "force_set_ethereum_account", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_set_ethereum_collection_id
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceSetEthereumCollectionId(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> ethereum_collection_id, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128> native_collection_id)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(ethereum_collection_id.Encode());
            byteArray.AddRange(native_collection_id.Encode());
            return new Method(253, "MultiTokens", 35, "force_set_ethereum_collection_id", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_set_unmintable_token_ids
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceSetUnmintableTokenIds(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> collection_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U64> base_token_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U64> token_index)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(collection_id.Encode());
            byteArray.AddRange(base_token_id.Encode());
            byteArray.AddRange(token_index.Encode());
            return new Method(253, "MultiTokens", 38, "force_set_unmintable_token_ids", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_create_ethereum_collection
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceCreateEthereumCollection(Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 owner, Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160 claimer, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> ethereum_collection_id, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.DefaultCollectionDescriptor descriptor)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(owner.Encode());
            byteArray.AddRange(claimer.Encode());
            byteArray.AddRange(ethereum_collection_id.Encode());
            byteArray.AddRange(descriptor.Encode());
            return new Method(253, "MultiTokens", 39, "force_create_ethereum_collection", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> force_set_ethereum_unmintable_token_ids
        /// Contains one variant per dispatchable that can be called by an extrinsic.
        /// </summary>
        public static Method ForceSetEthereumUnmintableTokenIds(Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128> ethereum_collection_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U64> base_token_id, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U64> token_index)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(ethereum_collection_id.Encode());
            byteArray.AddRange(base_token_id.Encode());
            byteArray.AddRange(token_index.Encode());
            return new Method(253, "MultiTokens", 40, "force_set_ethereum_unmintable_token_ids", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> MultiTokensConstants
    /// </summary>
    public sealed class MultiTokensConstants
    {
        
        /// <summary>
        /// >> AttributeDepositBase
        ///  The base deposit required for setting an attribute
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 AttributeDepositBase()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x0000C52EBCA2B1000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> AttributeDepositPerByte
        ///  Additional deposit per byte for setting an attribute
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 AttributeDepositPerByte()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x00901EC4BC1600000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxRecipientsPerBatchTransfer
        ///  The max number of recipients allowed in a batch transfer
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxRecipientsPerBatchTransfer()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0xFA000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxTokensPerBatchTransfer
        ///  The max number of tokens allowed in a batch transfer
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxTokensPerBatchTransfer()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0xF4010000");
            return result;
        }
        
        /// <summary>
        /// >> MaxBatchAttributesPerCall
        ///  The max number of attributes to set in one call
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxBatchAttributesPerCall()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x32000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxRecipientsPerBatchMint
        ///  The max number of recipients allowed in a batch mint
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxRecipientsPerBatchMint()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0xFA000000");
            return result;
        }
        
        /// <summary>
        /// >> CollectionCreationDeposit
        ///  Amount of [`Balance`](BalanceOf) reserved to create a collection
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 CollectionCreationDeposit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x000031D6E275BC560000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> TokenAccountDeposit
        ///  The amount of [`Balance`](BalanceOf) that must be reserved for a token account to be
        ///  maintained
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 TokenAccountDeposit()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U128();
            result.Create("0x0000C16FF28623000000000000000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxIdleOperationQueueLength
        ///  The maximum length of the idle operation queue
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxIdleOperationQueueLength()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0xE8030000");
            return result;
        }
        
        /// <summary>
        /// >> MaxIdleOperationQueueWeight
        ///  The maximum weight of the idle operation queue
        /// </summary>
        public Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_weights.weight_v2.Weight MaxIdleOperationQueueWeight()
        {
            var result = new Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_weights.weight_v2.Weight();
            result.Create("0x0700E876481700");
            return result;
        }
        
        /// <summary>
        /// >> MaxOperatorsPerAccount
        ///  The max number of operators a [`TokenAccount`] and an [`CollectionAccount`] can have
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxOperatorsPerAccount()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x0A000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxReserves
        ///  The maximum number of named reserves that can exist on an account
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxReserves()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x02000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxLocks
        ///  The maximum number of locks that can exist on a token account
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxLocks()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x02000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxExplicitRoyaltyCurrencies
        ///  The maximum number of explicit royalty currencies
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxExplicitRoyaltyCurrencies()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x0A000000");
            return result;
        }
        
        /// <summary>
        /// >> NativeAssetInfo
        ///  The [`NativeAssetInfo`](ep_multi_tokens::NativeAssetInfo) for this pallet
        /// </summary>
        public Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.types.NativeAssetInfo NativeAssetInfo()
        {
            var result = new Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.types.NativeAssetInfo();
            result.Create("0x000000C0A7C6B3D146310100000000000000");
            return result;
        }
        
        /// <summary>
        /// >> ReserveIdentifier
        ///  The id used for making reservations with this pallet
        /// </summary>
        public Substrate.Enjin.NET.NetApiExt.Generated.Types.Base.Arr8U8 ReserveIdentifier()
        {
            var result = new Substrate.Enjin.NET.NetApiExt.Generated.Types.Base.Arr8U8();
            result.Create("0x6D756C746F6B656E");
            return result;
        }
        
        /// <summary>
        /// >> TokenMetadataMaxNameLength
        ///  Max length of name stored in [`TokenMetadata`]
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 TokenMetadataMaxNameLength()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x20000000");
            return result;
        }
        
        /// <summary>
        /// >> TokenMetadataMaxSymbolLength
        ///  Max length of symbol stored in [`TokenMetadata`]
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 TokenMetadataMaxSymbolLength()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x08000000");
            return result;
        }
        
        /// <summary>
        /// >> MaxMigrationKeyLength
        ///  Max length for the [`Migrations`] storage
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxMigrationKeyLength()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x00040000");
            return result;
        }
        
        /// <summary>
        /// >> MigrationWeightLimitPercentage
        ///  Percentage of block weight to consume during migration
        /// </summary>
        public Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill MigrationWeightLimitPercentage()
        {
            var result = new Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill();
            result.Create("0x00E1F505");
            return result;
        }
        
        /// <summary>
        /// >> MaxMigrationExtrinsicInfosToPause
        ///  Bound for the number of extrinsics to pause during multi block migration
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxMigrationExtrinsicInfosToPause()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x14000000");
            return result;
        }
        
        /// <summary>
        /// >> MigrationExtrinsicsInfosToPause
        ///  List of extrinsics to pause during multi block migration (this pallet is excluded)
        /// </summary>
        public Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT43 MigrationExtrinsicsInfosToPause()
        {
            var result = new Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT43();
            result.Create("0x10244675656C54616E6B73002C4D756C7469546F6B656E7300345374616B6545786368616E67650" +
                    "03C4E6F6D696E6174696F6E506F6F6C7300");
            return result;
        }
        
        /// <summary>
        /// >> MaxClaimableCollectionsPerAccount
        ///  Max number of collections that can be claimed by an account
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaxClaimableCollectionsPerAccount()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x64000000");
            return result;
        }
        
        /// <summary>
        /// >> ClaimCollectionsPrefix
        ///  The prefix of the message used to claim collections
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8> ClaimCollectionsPrefix()
        {
            var result = new Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>();
            result.Create("0x805472616E7366657220636F6C6C656374696F6E7320746F206163636F756E743A");
            return result;
        }
        
        /// <summary>
        /// >> ClaimTokensPrefix
        ///  The prefix of the message used to claim tokens
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8> ClaimTokensPrefix()
        {
            var result = new Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>();
            result.Create("0x6C5472616E7366657220746F6B656E7320746F206163636F756E743A");
            return result;
        }
        
        /// <summary>
        /// >> EthereumMigrationAccountId
        ///  The account id that provides the existential deposit when claiming collections
        /// </summary>
        public Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 EthereumMigrationAccountId()
        {
            var result = new Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32();
            result.Create("0xB2FB867AF4B793DFAC6F50EDFEBFB2E7C9980621C37E6E92781865F71F93B265");
            return result;
        }
    }
    
    /// <summary>
    /// >> MultiTokensErrors
    /// </summary>
    public enum MultiTokensErrors
    {
        
        /// <summary>
        /// >> CollectionNotFound
        /// Collection was not found
        /// </summary>
        CollectionNotFound,
        
        /// <summary>
        /// >> CollectionAccountNotFound
        /// CollectionAccount was not found
        /// </summary>
        CollectionAccountNotFound,
        
        /// <summary>
        /// >> TokenNotFound
        /// Token was not found
        /// </summary>
        TokenNotFound,
        
        /// <summary>
        /// >> TokenAccountNotFound
        /// TokenAccount was not found
        /// </summary>
        TokenAccountNotFound,
        
        /// <summary>
        /// >> NoPermission
        /// Caller is not allowed to execute this extrinsic
        /// </summary>
        NoPermission,
        
        /// <summary>
        /// >> BalanceLow
        /// Not enough balance to perform the operation.
        /// </summary>
        BalanceLow,
        
        /// <summary>
        /// >> Frozen
        /// The operation failed due to an item being frozen
        /// </summary>
        Frozen,
        
        /// <summary>
        /// >> HasNeverFreezeState
        /// The token has a never freeze state. The state cannot be changed and the token cannot be
        /// frozen.
        /// </summary>
        HasNeverFreezeState,
        
        /// <summary>
        /// >> PermanentlyFrozen
        /// The token is permanently frozen
        /// </summary>
        PermanentlyFrozen,
        
        /// <summary>
        /// >> InvalidFreezeState
        /// The freeze state is not valid
        /// </summary>
        InvalidFreezeState,
        
        /// <summary>
        /// >> AmountZero
        /// An amount of zero was used when it's not allowed
        /// </summary>
        AmountZero,
        
        /// <summary>
        /// >> InvalidAttributeKey
        /// Attribute key invalid
        /// </summary>
        InvalidAttributeKey,
        
        /// <summary>
        /// >> MaxTokenCountExceeded
        /// Tried to mint more tokens than allowed
        /// </summary>
        MaxTokenCountExceeded,
        
        /// <summary>
        /// >> TokenMintCapExceeded
        /// The cap for the token was exceeded during mint
        /// </summary>
        TokenMintCapExceeded,
        
        /// <summary>
        /// >> TokenAlreadyExists
        /// Tried to create Token that already exists
        /// </summary>
        TokenAlreadyExists,
        
        /// <summary>
        /// >> DestroyForbiddenByAttributeCount
        /// The collection or token cannot be destroyed because it has attributes
        /// </summary>
        DestroyForbiddenByAttributeCount,
        
        /// <summary>
        /// >> DestroyForbiddenByRemainingTokens
        /// Destroy is not allowed on collections that have tokens. Destroy all tokens before
        /// calling [`destroy_collection`](Pallet::destroy_collection). Keep in mind that the
        /// [`Tokens`] storage can remain even if all of [`Token`](ep_multi_tokens::Token)'s units
        /// were burned. A token can only be destroyed by setting
        /// [`remove_token_storage`](OnBurnInput::remove_token_storage) to true in
        /// [`burn`](Pallet::burn).
        /// </summary>
        DestroyForbiddenByRemainingTokens,
        
        /// <summary>
        /// >> DestroyForbiddenByCollectionEvent
        /// The `OnCollectionEvent` trait has forbidden burning of the collection
        /// </summary>
        DestroyForbiddenByCollectionEvent,
        
        /// <summary>
        /// >> DepositReserveFailed
        /// Unable to reserve the amount to create a new collection/token
        /// </summary>
        DepositReserveFailed,
        
        /// <summary>
        /// >> DepositUnreserveFailed
        /// Unable to unreserve the amount to burn an existing collection/token
        /// </summary>
        DepositUnreserveFailed,
        
        /// <summary>
        /// >> InvalidUnitPrice
        /// The unit price cannot be zero, cannot decrease, and `unit_price * total_supply` must
        /// be greater than `TokenAccountDeposit`
        /// </summary>
        InvalidUnitPrice,
        
        /// <summary>
        /// >> BalanceBelowMinimumRequirement
        /// The balance is below the minimum required balance
        /// </summary>
        BalanceBelowMinimumRequirement,
        
        /// <summary>
        /// >> MintFailedRequirements
        /// The minting did not meet the requirements set by the mint policy
        /// </summary>
        MintFailedRequirements,
        
        /// <summary>
        /// >> IdleOperationQueueFull
        /// The idle operation queue is full and cannot accept new operations
        /// </summary>
        IdleOperationQueueFull,
        
        /// <summary>
        /// >> ReservesLow
        /// Reserved balance is not enough to perform the operation
        /// </summary>
        ReservesLow,
        
        /// <summary>
        /// >> TooManyReserves
        /// Max named reserves for an account are exceeded
        /// </summary>
        TooManyReserves,
        
        /// <summary>
        /// >> TooManyLocks
        /// Max named locks for an account are exceeded
        /// </summary>
        TooManyLocks,
        
        /// <summary>
        /// >> LiquidityRestrictions
        /// The balance is locked or restricted
        /// </summary>
        LiquidityRestrictions,
        
        /// <summary>
        /// >> PercentageOutOfBounds
        /// Royalty percentage is above or below allowed bounds
        /// </summary>
        PercentageOutOfBounds,
        
        /// <summary>
        /// >> CurrencyIncompatibleWithCollectionRoyalty
        /// Token cannot act as both a currency and a royalty
        /// </summary>
        CurrencyIncompatibleWithCollectionRoyalty,
        
        /// <summary>
        /// >> MaxApprovalsExceeded
        /// The max number of approvals for this account was exceeded
        /// </summary>
        MaxApprovalsExceeded,
        
        /// <summary>
        /// >> AlreadyExpired
        /// Tried to set an expiration that has already passed
        /// </summary>
        AlreadyExpired,
        
        /// <summary>
        /// >> CollectionAlreadyApproved
        /// The collection is already approved for all, so it is useless to approve for a single
        /// token
        /// </summary>
        CollectionAlreadyApproved,
        
        /// <summary>
        /// >> InsufficientAllowance
        /// Not enough allowance to perform the operation
        /// </summary>
        InsufficientAllowance,
        
        /// <summary>
        /// >> WrongCurrentApprovedAmount
        /// The passed `current_amount` does not match the actual current amount of the approval
        /// </summary>
        WrongCurrentApprovedAmount,
        
        /// <summary>
        /// >> CannotApproveSelf
        /// An account cannot approve itself as an operator
        /// </summary>
        CannotApproveSelf,
        
        /// <summary>
        /// >> CannotTransferToSelf
        /// An account cannot transfer tokens to itself
        /// </summary>
        CannotTransferToSelf,
        
        /// <summary>
        /// >> TransferParamCreationFailed
        /// Transfer params could not be created
        /// </summary>
        TransferParamCreationFailed,
        
        /// <summary>
        /// >> OperationNotAllowedForNativeToken
        /// This operation is not allowed for the native token
        /// </summary>
        OperationNotAllowedForNativeToken,
        
        /// <summary>
        /// >> InvalidExplicitRoyaltyCurrencies
        /// One or more of the explicit royalty currencies are invalid
        /// </summary>
        InvalidExplicitRoyaltyCurrencies,
        
        /// <summary>
        /// >> InvalidAttributeCount
        /// Provided attribute count doesnt match the count is storage
        /// </summary>
        InvalidAttributeCount,
        
        /// <summary>
        /// >> ConflictingLocation
        /// Conflicting MultiLocation for an AssetId
        /// </summary>
        ConflictingLocation,
        
        /// <summary>
        /// >> CollectionIdAlreadyInUse
        /// Collection ID is already in use
        /// </summary>
        CollectionIdAlreadyInUse,
        
        /// <summary>
        /// >> FreezeStateRequired
        /// Freeze state is required when freezing a token
        /// </summary>
        FreezeStateRequired,
        
        /// <summary>
        /// >> PremintExceeded
        /// The preminted amount would be exceeded by the mint operation
        /// </summary>
        PremintExceeded,
        
        /// <summary>
        /// >> TokenMetadataCreationFailed
        /// Token metadata could not be created from mint params
        /// </summary>
        TokenMetadataCreationFailed,
        
        /// <summary>
        /// >> NoClaimAvailable
        /// There is nothing to claim
        /// </summary>
        NoClaimAvailable,
        
        /// <summary>
        /// >> InvalidEthereumSignature
        /// The ethereum signature is invalid
        /// </summary>
        InvalidEthereumSignature,
        
        /// <summary>
        /// >> InvalidEthereumAddress
        /// The ethereum address does not match the signature
        /// </summary>
        InvalidEthereumAddress,
        
        /// <summary>
        /// >> TokenIdReservedForClaim
        /// The token id cannot be minted because it's reserved for claiming
        /// </summary>
        TokenIdReservedForClaim,
        
        /// <summary>
        /// >> CollectionCountExceeded
        /// The number of collections has exceeded the bound
        /// </summary>
        CollectionCountExceeded,
        
        /// <summary>
        /// >> WrongCount
        /// The passed count does not reflect the amount in storage
        /// </summary>
        WrongCount,
        
        /// <summary>
        /// >> InvalidMintParams
        /// Mint params are invalid
        /// </summary>
        InvalidMintParams,
    }
}
