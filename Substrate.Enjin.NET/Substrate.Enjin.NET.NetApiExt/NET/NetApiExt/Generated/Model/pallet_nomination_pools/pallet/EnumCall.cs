//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_nomination_pools.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains one variant per dispatchable that can be called by an extrinsic.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> bond
        /// Stake funds with a pool. The amount to bond is transferred from the member to the
        /// pools account and immediately increases the pools bond. The sENJ token will be minted
        /// and transferred to `origin`.
        /// 
        /// # Parameters
        /// - `origin`: the caller
        /// - `pool_id`: the pool id to bond
        /// - `amount`: the amount of tokens deposited into the pool
        /// 
        /// # Note
        /// 
        /// * An account can only be a member of a single pool.
        /// * An account cannot join the same pool multiple times.
        /// * This call will *not* dust the member account, so the member must have at least
        ///   `existential deposit + amount` in their account.
        /// * Only a pool with [`PoolState::Open`] can be joined
        /// </summary>
        bond = 0,
        
        /// <summary>
        /// >> unbond
        /// Unbond up to `unbonding_points` of the `member_account`'s funds from the pool by burning
        /// sENJ.
        /// 
        /// Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
        /// account).
        /// 
        /// # Conditions for a permissionless dispatch.
        /// 
        /// * The pool is blocked and the caller is holding the pool's token. This is refereed to as
        ///   a kick.
        /// * The pool is destroying.
        /// * The pool is destroying and no other members are in the pool.
        /// 
        /// ## Conditions for permissioned dispatch (i.e. the caller is also the
        /// `member_account`):
        /// 
        /// * The caller is not the last member.
        /// * The caller is the last member and the pool is destroying.
        /// 
        /// # Note
        /// 
        /// If there are too many unlocking chunks to unbond with the pool account,
        /// [`Call::pool_withdraw_unbonded`] can be called to try and minimize unlocking chunks.
        /// The [`StakingInterface::unbond`] will implicitly call [`Call::pool_withdraw_unbonded`]
        /// to try to free chunks if necessary (ie. if unbound was called and no unlocking chunks
        /// are available). However, it may not be possible to release the current unlocking chunks,
        /// in which case, the result of this call will likely be the `NoMoreChunks` error from the
        /// staking system.
        /// </summary>
        unbond = 3,
        
        /// <summary>
        /// >> pool_withdraw_unbonded
        /// Call `withdraw_unbonded` for the pools account. This call can be made by any account.
        /// 
        /// This is useful if their are too many unlocking chunks to call `unbond`, and some
        /// can be cleared by withdrawing. In the case there are too many unlocking chunks, the user
        /// would probably see an error like `NoMoreChunks` emitted from the staking system when
        /// they attempt to unbond.
        /// </summary>
        pool_withdraw_unbonded = 4,
        
        /// <summary>
        /// >> withdraw_unbonded
        /// Withdraw unbonded funds from `member_account`. If no bonded funds can be unbonded, an
        /// error is returned.
        /// 
        /// Under certain conditions, this call can be dispatched permissionlessly (i.e. by any
        /// account).
        /// 
        /// # Conditions for a permissionless dispatch
        /// 
        /// * The pool is in destroy mode.
        /// * The target is the only member in the sub pools.
        /// * The pool is blocked and the caller is either the admin or state-toggler.
        /// 
        /// # Conditions for permissioned dispatch
        /// 
        /// * The caller is the target and they are not the last member.
        /// 
        /// # Note
        /// 
        /// If the target is the last member, the pool will be destroyed.
        /// </summary>
        withdraw_unbonded = 5,
        
        /// <summary>
        /// >> create
        /// Create a new nomination pool.
        /// 
        /// # Arguments
        /// 
        /// * `token_id` - Token that that will control the pool. This token must be from the
        ///   [`Config::PoolCollectionId`] collection and it must be held by the caller.
        /// * `deposit` - The amount of funds to delegate to the pool. This also acts as a deposit
        ///   because the pool's creator cannot fully unbond funds until the pool is destroyed.
        /// * `capacity` - The maximum total balance allowed in the pool. This is measured in sENJ.
        ///   It must be below the pool's capacity. See `Capacity` section in crate level docs.
        /// * `duration` - The duration in blocks of the pool's bonus cycle
        /// 
        /// # Note
        /// 
        /// In addition to `deposit`, the caller will transfer the existential deposit for the
        /// pool's accounts; so the caller needs at have at least `deposit + existential_deposit *
        /// 2` transferable.
        /// </summary>
        create = 6,
        
        /// <summary>
        /// >> nominate
        /// Nominate on behalf of the pool.
        /// 
        /// The dispatch origin of this call must be signed by the holder of the pool token.
        /// 
        /// This directly forward the call to the staking pallet, on behalf of the pool bonded
        /// account.
        /// </summary>
        nominate = 8,
        
        /// <summary>
        /// >> set_configs
        /// Update configurations for the nomination pools. Callable only by
        /// [`Config::ForceOrigin`].
        /// 
        /// # Arguments
        /// 
        /// * `min_join_bond` - Set [`MinJoinBond`].
        /// * `min_create_bond` - Set [`MinCreateBond`].
        /// * `global_max_commission` - Set [`GlobalMaxCommission`].
        /// </summary>
        set_configs = 11,
        
        /// <summary>
        /// >> chill
        /// Chill on behalf of the pool.
        /// 
        /// The dispatch origin of this call must be signed by the pool token holder, same as
        /// [`Pallet::nominate`].
        /// 
        /// This directly forward the call to the staking pallet, on behalf of the pool bonded
        /// account.
        /// </summary>
        chill = 13,
        
        /// <summary>
        /// >> destroy
        /// Destroy the pool.
        /// 
        /// The dispatch origin of this call must be signed by the account holding the pool token
        /// of the given pool_id.
        /// </summary>
        destroy = 14,
        
        /// <summary>
        /// >> payout_rewards
        /// Pays rewards to `validator_stash` and also distributes rewards to the reward accounts of
        /// the pools nominating it. The appropriate bonus is also calculated and stored in the
        /// bonus account.
        /// 
        /// This should be called once per era per validator. It is a permissionless call. It also
        /// processes rewards for the previous era if [`Self::process_payouts`] was not called.
        /// 
        /// ## Bonus Calculation
        /// 
        /// 1. Minimum duration and max duration are found for all pools nominating
        ///    `validator_stash`
        /// 2. [`Config::BonusPercentage`] is set aside from rewards for bonus
        /// 3. Normalized weight is calculated and then scaled according to the total bonus. See
        ///    `functions::calculate_real_weight`.
        /// 4. The scaled weight is offset according to [`Config::BaseBonusRewardPercentage`] so
        ///    that all pools at least get the minimum weight
        /// 5. Final calculation is done in [`traits::Bonus::calculate_bonus`] and then transferred
        ///    to the bonus account
        /// </summary>
        payout_rewards = 18,
        
        /// <summary>
        /// >> process_payouts
        /// Processes the rewards for all pools that were distributed in [`Self::payout_rewards`].
        /// It will only succeed if it is called on the same era that payouts were made. It uses the
        /// [`EraPayoutInfo`] storage to verify this. This extrinsic is permissionless.
        /// 
        /// The following is done for each pool:
        /// 1. If the pool has reached the end of its cycle, it cycles the pool.
        /// 2. Sends bonus for the current era from the bonus account to the rewards account.
        /// 3. Sends reward commission to the depositor.
        /// 4. It bonds the pool's reward balance.
        /// 
        /// It is not required to call this extrinsic. If it is not called, the rewards will be
        /// processed when `payout_rewards` is called in the next era.
        /// </summary>
        process_payouts = 25,
        
        /// <summary>
        /// >> mutate
        /// Mutate the nomination pool data.
        /// 
        /// The dispatch origin of this call must be signed by the account holding the pool token
        /// of the given pool_id.
        /// </summary>
        mutate = 19,
        
        /// <summary>
        /// >> unbond_deposit
        /// Unbonds the deposit
        /// 
        /// This call is permissionless but certain conditions must be met before the deposit can
        /// be unbonded:
        /// 
        /// - Pool must be in [`PoolState::Destroying`] mode
        /// - Deposit points must be the only points in the pool
        /// - [`UnbondingMembers`] must be empty
        /// 
        /// This will unbond the deposit from the pool.
        /// </summary>
        unbond_deposit = 20,
        
        /// <summary>
        /// >> withdraw_deposit
        /// Withdraws the deposit
        /// 
        /// This call is permissionless and should be called after the deposit has been unbonded.
        /// </summary>
        withdraw_deposit = 21,
        
        /// <summary>
        /// >> withdraw_free_balance
        /// Transfers `amount` from the pool's free balance to `destination`. Only callable by
        /// [`Config::ForceOrigin`].
        /// </summary>
        withdraw_free_balance = 26,
        
        /// <summary>
        /// >> set_staking_info
        /// Set the annual inflation rate and collator payout cut
        /// 
        /// Callable only by [`Config::ForceOrigin`]
        /// </summary>
        set_staking_info = 22,
        
        /// <summary>
        /// >> calculate_early_bird_bonus
        /// Calculate and prepare early bird bonus if it is ready to be queued.
        /// 
        /// Callable by any signed origin after [`Config::EarlyBirdBonusDistributionBlock`].
        /// 
        /// ## Details
        /// 
        /// 1. Calculates the normalized weights for each pool by calling
        ///    [`Pallet::early_bird_normalized_weight`]. Factors for the weight are each pool's
        ///    total points and the creation date.
        /// 2. Each pool's weight is multiplied by the total reward to determine each pool's reward.
        /// 3. The rewards are stored in [`PoolBonusInfos`] and can be distributed by calling
        ///    [`Self::pay_early_bird_bonus`].
        /// </summary>
        calculate_early_bird_bonus = 23,
        
        /// <summary>
        /// >> unlock_early_bird_bonus
        /// Unlock early bird bonus to pools. This extrinsic will ensure the
        /// EarlyBirdBonusDistributionBlock has passed before the bonus is unlocked.
        /// Callable by any signed origin after the bonus has been queued.
        /// </summary>
        unlock_early_bird_bonus = 28,
        
        /// <summary>
        /// >> capture_early_bird_bonus_shares
        /// Stores the share of sENJ balance for each account staked in `pool_id`.
        /// </summary>
        capture_early_bird_bonus_shares = 27,
        
        /// <summary>
        /// >> pay_early_bird_bonus
        /// Pay early bird bonus to pools. The `account_count` parameter is the max number
        /// of pool user accounts to be paid in this call.
        /// 
        /// Callable by any signed origin after the bonus has been unlocked
        /// </summary>
        pay_early_bird_bonus = 24,
    }
    
    /// <summary>
    /// >> 408 - Variant[pallet_nomination_pools.pallet.Call]
    /// Contains one variant per dispatchable that can be called by an extrinsic.
    /// </summary>
    public sealed class EnumCall : BaseEnumExt<Call, BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_nomination_pools.types.EnumBondValue>, BaseVoid, BaseVoid, BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>, BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>, BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Primitive.U32>, BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT1>, BaseVoid, BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>>, BaseVoid, BaseVoid, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_nomination_pools.types.EnumConfigOp, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_nomination_pools.types.EnumConfigOp, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_nomination_pools.types.EnumConfigOp, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_nomination_pools.types.EnumConfigOp>, BaseVoid, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32, BaseVoid, BaseVoid, BaseVoid, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>, BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_nomination_pools.types.PoolMutation>, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_nomination_pools.types.StakingInfo, Substrate.NetApi.Model.Types.Primitive.U32, BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.NetApi.Model.Types.Primitive.U32, BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Primitive.U128>, BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>, BaseVoid>
    {
    }
}
