//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_staking.pallet.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains one variant per dispatchable that can be called by an extrinsic.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> bond
        /// Take the origin account as a stash and lock up `value` of its balance. `controller` will
        /// be the account that controls it.
        /// 
        /// `value` must be more than the `minimum_balance` specified by `T::Currency`.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the stash account.
        /// 
        /// Emits `Bonded`.
        /// ## Complexity
        /// - Independent of the arguments. Moderate complexity.
        /// - O(1).
        /// - Three extra DB entries.
        /// 
        /// NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned
        /// unless the `origin` falls below _existential deposit_ and gets removed as dust.
        /// </summary>
        bond = 0,
        
        /// <summary>
        /// >> bond_extra
        /// Add some extra amount that have appeared in the stash `free_balance` into the balance up
        /// for staking.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the stash, not the controller.
        /// 
        /// Use this if there are additional funds in your stash account that you wish to bond.
        /// Unlike [`bond`](Self::bond) or [`unbond`](Self::unbond) this function does not impose
        /// any limitation on the amount that can be added.
        /// 
        /// Emits `Bonded`.
        /// 
        /// ## Complexity
        /// - Independent of the arguments. Insignificant complexity.
        /// - O(1).
        /// </summary>
        bond_extra = 1,
        
        /// <summary>
        /// >> unbond
        /// Schedule a portion of the stash to be unlocked ready for transfer out after the bond
        /// period ends. If this leaves an amount actively bonded less than
        /// T::Currency::minimum_balance(), then it is increased to the full amount.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// 
        /// Once the unlock period is done, you can call `withdraw_unbonded` to actually move
        /// the funds out of management ready for transfer.
        /// 
        /// No more than a limited number of unlocking chunks (see `MaxUnlockingChunks`)
        /// can co-exists at the same time. If there are no unlocking chunks slots available
        /// [`Call::withdraw_unbonded`] is called to remove some of the chunks (if possible).
        /// 
        /// If a user encounters the `InsufficientBond` error when calling this extrinsic,
        /// they should call `chill` first in order to free up their bonded funds.
        /// 
        /// Emits `Unbonded`.
        /// 
        /// See also [`Call::withdraw_unbonded`].
        /// </summary>
        unbond = 2,
        
        /// <summary>
        /// >> withdraw_unbonded
        /// Remove any unlocked chunks from the `unlocking` queue from our management.
        /// 
        /// This essentially frees up that balance to be used by the stash account to do
        /// whatever it wants.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller.
        /// 
        /// Emits `Withdrawn`.
        /// 
        /// See also [`Call::unbond`].
        /// 
        /// ## Complexity
        /// O(S) where S is the number of slashing spans to remove
        /// NOTE: Weight annotation is the kill scenario, we refund otherwise.
        /// </summary>
        withdraw_unbonded = 3,
        
        /// <summary>
        /// >> validate
        /// Declare the desire to validate for the origin controller.
        /// 
        /// Effects will be felt at the beginning of the next era.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// </summary>
        validate = 4,
        
        /// <summary>
        /// >> nominate
        /// Declare the desire to nominate `targets` for the origin controller.
        /// 
        /// Effects will be felt at the beginning of the next era.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// 
        /// ## Complexity
        /// - The transaction's complexity is proportional to the size of `targets` (N)
        /// which is capped at CompactAssignments::LIMIT (T::MaxNominations).
        /// - Both the reads and writes follow a similar pattern.
        /// </summary>
        nominate = 5,
        
        /// <summary>
        /// >> chill
        /// Declare no desire to either validate or nominate.
        /// 
        /// Effects will be felt at the beginning of the next era.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// 
        /// ## Complexity
        /// - Independent of the arguments. Insignificant complexity.
        /// - Contains one read.
        /// - Writes are limited to the `origin` account key.
        /// </summary>
        chill = 6,
        
        /// <summary>
        /// >> set_payee
        /// (Re-)set the payment target for a controller.
        /// 
        /// Effects will be felt instantly (as soon as this function is completed successfully).
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// 
        /// ## Complexity
        /// - O(1)
        /// - Independent of the arguments. Insignificant complexity.
        /// - Contains a limited number of reads.
        /// - Writes are limited to the `origin` account key.
        /// ---------
        /// </summary>
        set_payee = 7,
        
        /// <summary>
        /// >> set_controller
        /// (Re-)sets the controller of a stash to the stash itself. This function previously
        /// accepted a `controller` argument to set the controller to an account other than the
        /// stash itself. This functionality has now been removed, now only setting the controller
        /// to the stash, if it is not already.
        /// 
        /// Effects will be felt instantly (as soon as this function is completed successfully).
        /// 
        /// The dispatch origin for this call must be _Signed_ by the stash, not the controller.
        /// 
        /// ## Complexity
        /// O(1)
        /// - Independent of the arguments. Insignificant complexity.
        /// - Contains a limited number of reads.
        /// - Writes are limited to the `origin` account key.
        /// </summary>
        set_controller = 8,
        
        /// <summary>
        /// >> set_validator_count
        /// Sets the ideal number of validators.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// ## Complexity
        /// O(1)
        /// </summary>
        set_validator_count = 9,
        
        /// <summary>
        /// >> increase_validator_count
        /// Increments the ideal number of validators upto maximum of
        /// `ElectionProviderBase::MaxWinners`.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// ## Complexity
        /// Same as [`Self::set_validator_count`].
        /// </summary>
        increase_validator_count = 10,
        
        /// <summary>
        /// >> scale_validator_count
        /// Scale up the ideal number of validators by a factor upto maximum of
        /// `ElectionProviderBase::MaxWinners`.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// ## Complexity
        /// Same as [`Self::set_validator_count`].
        /// </summary>
        scale_validator_count = 11,
        
        /// <summary>
        /// >> force_no_eras
        /// Force there to be no new eras indefinitely.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// # Warning
        /// 
        /// The election process starts multiple blocks before the end of the era.
        /// Thus the election process may be ongoing when this is called. In this case the
        /// election will continue until the next era is triggered.
        /// 
        /// ## Complexity
        /// - No arguments.
        /// - Weight: O(1)
        /// </summary>
        force_no_eras = 12,
        
        /// <summary>
        /// >> force_new_era
        /// Force there to be a new era at the end of the next session. After this, it will be
        /// reset to normal (non-forced) behaviour.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// # Warning
        /// 
        /// The election process starts multiple blocks before the end of the era.
        /// If this is called just before a new era is triggered, the election process may not
        /// have enough blocks to get a result.
        /// 
        /// ## Complexity
        /// - No arguments.
        /// - Weight: O(1)
        /// </summary>
        force_new_era = 13,
        
        /// <summary>
        /// >> set_invulnerables
        /// Set the validators who cannot be slashed (if any).
        /// 
        /// The dispatch origin must be Root.
        /// </summary>
        set_invulnerables = 14,
        
        /// <summary>
        /// >> force_unstake
        /// Force a current staker to become completely unstaked, immediately.
        /// 
        /// The dispatch origin must be Root.
        /// </summary>
        force_unstake = 15,
        
        /// <summary>
        /// >> force_new_era_always
        /// Force there to be a new era at the end of sessions indefinitely.
        /// 
        /// The dispatch origin must be Root.
        /// 
        /// # Warning
        /// 
        /// The election process starts multiple blocks before the end of the era.
        /// If this is called just before a new era is triggered, the election process may not
        /// have enough blocks to get a result.
        /// </summary>
        force_new_era_always = 16,
        
        /// <summary>
        /// >> cancel_deferred_slash
        /// Cancel enactment of a deferred slash.
        /// 
        /// Can be called by the `T::AdminOrigin`.
        /// 
        /// Parameters: era and indices of the slashes for that era to kill.
        /// </summary>
        cancel_deferred_slash = 17,
        
        /// <summary>
        /// >> payout_stakers
        /// Pay out all the stakers behind a single validator for a single era.
        /// 
        /// - `validator_stash` is the stash account of the validator. Their nominators, up to
        ///   `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.
        /// - `era` may be any era between `[current_era - history_depth; current_era]`.
        /// 
        /// The origin of this call must be _Signed_. Any account can call this function, even if
        /// it is not one of the stakers.
        /// 
        /// ## Complexity
        /// - At most O(MaxNominatorRewardedPerValidator).
        /// </summary>
        payout_stakers = 18,
        
        /// <summary>
        /// >> rebond
        /// Rebond a portion of the stash scheduled to be unlocked.
        /// 
        /// The dispatch origin must be signed by the controller.
        /// 
        /// ## Complexity
        /// - Time complexity: O(L), where L is unlocking chunks
        /// - Bounded by `MaxUnlockingChunks`.
        /// </summary>
        rebond = 19,
        
        /// <summary>
        /// >> reap_stash
        /// Remove all data structures concerning a staker/stash once it is at a state where it can
        /// be considered `dust` in the staking system. The requirements are:
        /// 
        /// 1. the `total_balance` of the stash is below existential deposit.
        /// 2. or, the `ledger.total` of the stash is below existential deposit.
        /// 
        /// The former can happen in cases like a slash; the latter when a fully unbonded account
        /// is still receiving staking rewards in `RewardDestination::Staked`.
        /// 
        /// It can be called by anyone, as long as `stash` meets the above requirements.
        /// 
        /// Refunds the transaction fees upon successful execution.
        /// </summary>
        reap_stash = 20,
        
        /// <summary>
        /// >> kick
        /// Remove the given nominations from the calling validator.
        /// 
        /// Effects will be felt at the beginning of the next era.
        /// 
        /// The dispatch origin for this call must be _Signed_ by the controller, not the stash.
        /// 
        /// - `who`: A list of nominator stash accounts who are nominating this validator which
        ///   should no longer be nominating this validator.
        /// 
        /// Note: Making this call only makes sense if you first set the validator preferences to
        /// block any further nominations.
        /// </summary>
        kick = 21,
        
        /// <summary>
        /// >> set_staking_configs
        /// Update the various staking configurations .
        /// 
        /// * `min_nominator_bond`: The minimum active bond needed to be a nominator.
        /// * `min_validator_bond`: The minimum active bond needed to be a validator.
        /// * `max_nominator_count`: The max number of users who can be a nominator at once. When
        ///   set to `None`, no limit is enforced.
        /// * `max_validator_count`: The max number of users who can be a validator at once. When
        ///   set to `None`, no limit is enforced.
        /// * `chill_threshold`: The ratio of `max_nominator_count` or `max_validator_count` which
        ///   should be filled in order for the `chill_other` transaction to work.
        /// * `min_commission`: The minimum amount of commission that each validators must maintain.
        ///   This is checked only upon calling `validate`. Existing validators are not affected.
        /// 
        /// RuntimeOrigin must be Root to call this function.
        /// 
        /// NOTE: Existing nominators and validators will not be affected by this update.
        /// to kick people under the new limits, `chill_other` should be called.
        /// </summary>
        set_staking_configs = 22,
        
        /// <summary>
        /// >> chill_other
        /// Declare a `controller` to stop participating as either a validator or nominator.
        /// 
        /// Effects will be felt at the beginning of the next era.
        /// 
        /// The dispatch origin for this call must be _Signed_, but can be called by anyone.
        /// 
        /// If the caller is the same as the controller being targeted, then no further checks are
        /// enforced, and this function behaves just like `chill`.
        /// 
        /// If the caller is different than the controller being targeted, the following conditions
        /// must be met:
        /// 
        /// * `controller` must belong to a nominator who has become non-decodable,
        /// 
        /// Or:
        /// 
        /// * A `ChillThreshold` must be set and checked which defines how close to the max
        ///   nominators or validators we must reach before users can start chilling one-another.
        /// * A `MaxNominatorCount` and `MaxValidatorCount` must be set which is used to determine
        ///   how close we are to the threshold.
        /// * A `MinNominatorBond` and `MinValidatorBond` must be set and checked, which determines
        ///   if this is a person that should be chilled because they have not met the threshold
        ///   bond required.
        /// 
        /// This can be helpful if bond requirements are updated, and we need to remove old users
        /// who do not satisfy these requirements.
        /// </summary>
        chill_other = 23,
        
        /// <summary>
        /// >> force_apply_min_commission
        /// Force a validator to have at least the minimum commission. This will not affect a
        /// validator who already has a commission greater than or equal to the minimum. Any account
        /// can call this.
        /// </summary>
        force_apply_min_commission = 24,
        
        /// <summary>
        /// >> set_min_commission
        /// Sets the minimum amount of commission that each validators must maintain.
        /// 
        /// This call has lower privilege requirements than `set_staking_config` and can be called
        /// by the `T::AdminOrigin`. Root can always call this.
        /// </summary>
        set_min_commission = 25,
    }
    
    /// <summary>
    /// >> 373 - Variant[pallet_staking.pallet.pallet.Call]
    /// Contains one variant per dispatchable that can be called by an extrinsic.
    /// </summary>
    public sealed class EnumCall : BaseEnumExt<Call, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_staking.EnumRewardDestination>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress>, BaseVoid, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_staking.EnumRewardDestination, BaseVoid, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent, BaseVoid, BaseVoid, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>, BaseVoid, BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp, Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_staking.pallet.pallet.EnumConfigOp>, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill>
    {
    }
}
