//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_multi_tokens.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains one variant per dispatchable that can be called by an extrinsic.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> create_collection
        /// Creates a new [`Collection`](ep_multi_tokens::Collection) from `descriptor`
        /// 
        /// # Errors
        /// 
        /// - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
        /// </summary>
        create_collection = 0,
        
        /// <summary>
        /// >> destroy_collection
        /// Destroys [`Collection`](ep_multi_tokens::Collection) with `id`. `origin` must be the
        /// owner of the [`Collection`](ep_multi_tokens::Collection).
        /// 
        /// # Errors
        /// 
        /// - [`Error::NoPermission`] if `origin` is not the owner of the collection.
        /// - [`Error::CollectionNotFound`] if `Collection` with `id` does not exist.
        /// - [`Error::DestroyForbiddenByCollectionEvent`] if another pallet is blocking the
        ///   collection's destruction
        /// - [`Error::DestroyForbiddenByRemainingTokens`] if collection still has tokens when
        ///   destroying
        /// - [`Error::DestroyForbiddenByAttributeCount`] if collection still has attributes when
        ///   destroying
        /// current number of collection attributes.
        /// </summary>
        destroy_collection = 1,
        
        /// <summary>
        /// >> mutate_collection
        /// Modify [`Collection`](ep_multi_tokens::Collection) with `id` by applying `mutation`
        /// 
        /// # Errors
        /// 
        /// - [`Error::CollectionNotFound`] if `collection_id` does not exist.
        /// - [`Error::NoPermission`] if `origin` is not the owner of `collection`.
        /// </summary>
        mutate_collection = 2,
        
        /// <summary>
        /// >> mutate_token
        /// Modify [`Token`](ep_multi_tokens::Token) with `token_id`  from
        /// [`Collection`](ep_multi_tokens::Collection) with `collection_id` by applying `mutation`
        /// 
        /// # Errors
        /// 
        /// - [`Error::CurrencyIncompatibleWithCollectionRoyalty`] if token has already been
        ///   assigned a royalty
        /// - [`Error::NoPermission`] if not the collection owner
        /// - [`Error::TokenNotFound`] if Token does not exist
        /// - [`Error::ConflictingLocation`] if the new location is already occupied
        /// </summary>
        mutate_token = 3,
        
        /// <summary>
        /// >> mint
        /// `origin` mints to `recipient` for `collection_id` with `params` using the pallet's
        /// [`MintPolicy`](traits::CollectionPolicy::Mint).
        /// 
        /// # Errors
        /// 
        /// - [`Error::AmountZero`] if `amount == 0`.
        /// - [`Error::CollectionNotFound`] if `Collection` does not exist.
        /// - [`Error::TokenNotFound`] if `Token` does not exist.
        /// - [`Error::TokenAlreadyExists`] if attempting to create a token that already exists
        /// - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
        /// - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
        /// - `MaxTokenCountExceeded` if the mint policy max_token_count is exceeded
        /// - [`Error::DepositReserveFailed`] if the issuer does not have sufficient balance for
        ///   token deposit
        /// - [`Error::ConflictingLocation`] if the token is foreign and the location is already
        ///   mapped to another asset in `AssetIdsByLocation`
        /// </summary>
        mint = 4,
        
        /// <summary>
        /// >> burn
        /// Reduces the balance of `owner` by `amount` of `token_id` from `collection_id`.
        /// It also updates the total supply of `collection_id`.
        /// 
        /// # Errors
        /// - [`Error::CollectionNotFound`] if `collection` does not exist.
        /// - [`Error::BalanceLow`] if `owner` account does not has enough amount of any token in
        ///   `tokens` of `collection`.
        /// - [`Error::DepositUnreserveFailed`] if caller does not have enough reserved balance to
        ///   unreserve
        /// - [`Error::DestroyForbiddenByAttributeCount`] if removing token from storage but the
        ///   attribute count is greater than zero
        /// </summary>
        burn = 5,
        
        /// <summary>
        /// >> transfer
        /// `operator` transfers to `recipient` for `collection_id` with `params`
        /// 
        /// # Errors
        /// 
        /// - [`Error::AmountZero`] if `amount == 0`.
        /// - [`Error::BalanceLow`] if `source` does not own enough amount of `collection`.
        /// </summary>
        transfer = 6,
        
        /// <summary>
        /// >> freeze
        /// Freeze collection, token or account
        /// </summary>
        freeze = 7,
        
        /// <summary>
        /// >> thaw
        /// Thaw collection, token or account
        /// </summary>
        thaw = 8,
        
        /// <summary>
        /// >> set_attribute
        /// Sets the attribute `key` to `value` for `collection_id`.
        /// If `token_id` is [`None`], the attribute is added to the collection. If it is [`Some`],
        /// the attribute is added to the token.
        /// 
        /// # Errors
        /// - [`Error::InvalidAttributeKey`] if `key.len() == 0`
        /// - [`Error::CollectionNotFound`] if `collection_id` does not exist.
        /// - [`Error::TokenNotFound`] if `token_id` is `Some` and does not exist.
        /// - [`Error::NoPermission`] if `source` account is not the owner of the collection.
        /// - [`Error::DepositReserveFailed`] if unable to reserve the deposit for the attribute
        ///   storage.
        /// </summary>
        set_attribute = 9,
        
        /// <summary>
        /// >> remove_attribute
        /// Removes the `key` attribute from the given `collection_id` or `token_id`.
        /// 
        /// # Errors
        /// - [`Error::InvalidAttributeKey`] if `key.len() == 0`
        /// - [`Error::CollectionNotFound`] if `collection_id` does not exist.
        /// - [`Error::TokenNotFound`] if `token_id` is `Some` and does not exist.
        /// - [`Error::NoPermission`] if `caller` is not the owner of the collection.
        /// - `Underflow` if an attribute counter underflows
        /// </summary>
        remove_attribute = 10,
        
        /// <summary>
        /// >> remove_all_attributes
        /// Removes all attributes from the given `collection_id` or `token_id`.
        /// 
        /// # Errors
        /// - `InvalidAttributeCount` if `attribute_count` doesn't match the number of attributes
        /// - [`Error::CollectionNotFound`] if Collection with `collection_id` does not exist.
        /// - [`Error::TokenNotFound`] if Token with `token_id` does not exist.
        /// - [`Error::NoPermission`] if `origin` account is not the owner of the Collection or
        ///   Token
        /// - other errors from `remove_attribute`
        /// </summary>
        remove_all_attributes = 11,
        
        /// <summary>
        /// >> batch_transfer
        /// Transfers the specific amount of tokens of `collection` to `recipients` from `origin`
        /// account. A single failure will fail all transfers.
        /// 
        /// # Errors
        /// 
        /// - [`Error::AmountZero`] if `amount == 0`.
        /// - [`Error::BalanceLow`] if `source` does not own enough amount of `collection`.
        /// </summary>
        batch_transfer = 12,
        
        /// <summary>
        /// >> batch_mint
        /// Collection owner mints tokens of `collection_id` to `recipients` consisting of an
        /// [`AccountId`](frame_system::Config::AccountId) and [`MintParams`]. A single mint failure
        /// will fail all of them in the batch.
        /// 
        /// # Errors
        /// - [`Error::AmountZero`] if `amount == 0`.
        /// - [`Error::CollectionNotFound`] if `collection` does **not** exist.
        /// - [`Error::NoPermission`] if `caller` is not allowed to mint the `collection`.
        /// - [`Error::TokenMintCapExceeded`] if the mint policy TokenCap does not allow minting
        /// - [`Error::MaxTokenCountExceeded`] if the mint policy max_token_count is exceeded
        /// - [`Error::DepositReserveFailed`] if the issuer does not have sufficient balance for
        ///   token deposit
        /// </summary>
        batch_mint = 13,
        
        /// <summary>
        /// >> batch_set_attribute
        /// Collection owner sets `attributes` to `collection_id`
        /// 
        /// If `token_id` is [`None`], the attribute is added to the collection. If it is [`Some`],
        /// the attribute is added to the token.
        /// 
        /// # Errors
        /// 
        /// - [`Error::InvalidAttributeKey`] if `key.len() == 0`
        /// - [`Error::CollectionNotFound`] if `collection_id` does not exist.
        /// - [`Error::TokenNotFound`] if `token_id` is `Some` and does not exist.
        /// - [`Error::NoPermission`] if `source` account is not the owner of the collection.
        /// - [`Error::DepositReserveFailed`] if unable to reserve the deposit for the attribute
        ///   storage.
        /// </summary>
        batch_set_attribute = 14,
        
        /// <summary>
        /// >> approve_collection
        /// Approve the `operator` to manage all of `origin`'s tokens belonging to `collection_id`.
        /// If an `expiration` is provided, the approval will end when it expires.
        /// 
        /// # Errors
        /// 
        /// - [`Error::CannotApproveSelf`] if `origin == operator`
        /// - [`Error::AlreadyExpired`] if `expiration` is earlier than now
        /// - [`Error::CollectionAccountNotFound`] if the collection account does not exist
        /// - [`Error::MaxApprovalsExceeded`] if approval count has exceeded the maximum
        /// </summary>
        approve_collection = 15,
        
        /// <summary>
        /// >> unapprove_collection
        /// Unapprove the `operator` to manage all of `origin`'s tokens belonging to `collection`
        /// 
        /// # Errors
        /// 
        /// - [`Error::CollectionAccountNotFound`] if the collection account cannot be found
        /// </summary>
        unapprove_collection = 16,
        
        /// <summary>
        /// >> approve_token
        /// Approve `operator` to transfer up to `amount` of `caller`'s balance for `token_id` of
        /// `collection_id`. An `expiration` can be provided. `current_amount` must match the
        /// current approved amount.
        /// 
        /// # Errors
        /// - [`Error::CannotApproveSelf`] if `origin == operator`
        /// - [`Error::CollectionAlreadyApproved`] if `collection_id` is already approved
        /// - [`Error::AlreadyExpired`] if `expiration` is earlier than now
        /// - [`Error::TokenAccountNotFound`] if the token account does not exist
        /// - [`Error::MaxApprovalsExceeded`] if approval count has exceeded the maximum
        /// - [`Error::WrongCurrentApprovedAmount`] if `current_amount` does not match the current
        ///   approval amount
        /// </summary>
        approve_token = 17,
        
        /// <summary>
        /// >> unapprove_token
        /// Unapprove `operator` to transfer `origin`'s `token_id` of `collection_id`
        /// 
        /// # Errors
        /// 
        /// - [`Error::TokenAccountNotFound`] if the token account does not exist
        /// </summary>
        unapprove_token = 18,
        
        /// <summary>
        /// >> claim_collections
        /// Transfers ownership of collections to `destination` if the signature and
        /// `collection_count` matches.
        /// 
        /// The dispatch origin for this call must be _None_.
        /// 
        /// Unsigned Validation:
        /// A call to claim is deemed valid if the signature provided matches
        /// the expected signed message of:
        /// 
        /// > Ethereum Signed Message:
        /// > (configured prefix string)(address)
        /// 
        /// and `address` matches the `destination` account.
        /// 
        /// This will always execute with weight of [`Config::MaxClaimableCollectionsPerAccount`]
        /// and it will reimburse weight for collections under that number.
        /// 
        /// ### Parameters:
        /// - `destination`: The account that will receive ownership of the collections
        /// - `ethereum_signature`: The signature of an ethereum signed message matching the format
        ///   described above.
        /// - `ethereum_address`: The Ethereum address from which the message is signed.
        /// - `collection_count`: The number of collections that will be claimed. It can also be
        ///   higher than the actual number, but if it's lower it will fail.
        /// </summary>
        claim_collections = 32,
        
        /// <summary>
        /// >> claim_tokens
        /// Sends [`Event::ClaimTokensInitiated`] event if validation of the params succeeds.
        /// 
        /// The dispatch origin for this call must be _None_.
        /// 
        /// Unsigned Validation:
        /// A call to claim is deemed valid if the signature provided matches
        /// the expected signed message of:
        /// 
        /// > Ethereum Signed Message:
        /// > (configured prefix string)(address)
        /// 
        /// and `address` matches the `destination` account.
        /// 
        /// ### Parameters:
        /// - `destination`: The account that will receive token balances
        /// - `ethereum_signature`: The signature of an ethereum signed message matching the format
        ///   described above.
        /// - `ethereum_address` : The Ethereum address from which the message is signed.
        /// </summary>
        claim_tokens = 33,
        
        /// <summary>
        /// >> finish_claim_tokens
        /// Sends an event that signifies claiming the tokens was completed. Only callable by
        /// [`Config::EthereumMigrationOrigin`].
        /// </summary>
        finish_claim_tokens = 36,
        
        /// <summary>
        /// >> force_mutate_collection
        /// Exactly as [`mutate_collection`](Self::mutate_collection), except the origin must be
        /// root and the `caller` account should be specified.
        /// 
        /// # Errors
        /// 
        /// Same as [`mutate_collection`](Self::mutate_collection)
        /// </summary>
        force_mutate_collection = 19,
        
        /// <summary>
        /// >> force_transfer
        /// Exactly as [`transfer`](Self::transfer), except the origin must be root and the source
        /// account should be specified.
        /// 
        /// # Errors
        /// 
        /// Same as [`transfer`](Self::transfer)
        /// </summary>
        force_transfer = 20,
        
        /// <summary>
        /// >> force_set_collection
        /// Set the Collections storage to the given `value`, origin must be root
        /// </summary>
        force_set_collection = 21,
        
        /// <summary>
        /// >> force_set_token
        /// Set the Tokens storage to the given `value`, origin must be root
        /// </summary>
        force_set_token = 22,
        
        /// <summary>
        /// >> force_set_attribute
        /// Set the Tokens storage to the given `value`, origin must be root
        /// </summary>
        force_set_attribute = 23,
        
        /// <summary>
        /// >> force_set_collection_account
        /// Set the CollectionAccounts storage to the given `value`, origin must be root
        /// </summary>
        force_set_collection_account = 24,
        
        /// <summary>
        /// >> force_set_token_account
        /// Set the TokenAccounts storage to the given `value`, origin must be root
        /// </summary>
        force_set_token_account = 25,
        
        /// <summary>
        /// >> force_create_collection
        /// Creates a new collection from `descriptor` at `collection_id`, origin must be root
        /// 
        /// # Errors
        /// - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
        /// - [`Error::CollectionIdAlreadyInUse`] if the collection id is already in use
        /// </summary>
        force_create_collection = 26,
        
        /// <summary>
        /// >> force_mint
        /// Same as [`mint`](Self::mint), but it is callable by
        /// [`Config::EthereumMigrationOrigin`]. If `caller` is None, it will use the collection
        /// owner. If `depositor` is `Some`, they will pay the deposit for minting.
        /// </summary>
        force_mint = 27,
        
        /// <summary>
        /// >> force_burn
        /// Same as [`burn`](Self::burn), but it is only callable by
        /// [`Config::ForceOrigin`]. Executes the burn by `caller`.
        /// </summary>
        force_burn = 28,
        
        /// <summary>
        /// >> force_approve_collection
        /// Same as [`approve_collection`](Self::approve_collection), but it is callable by
        /// [`Config::ForceOrigin`].
        /// </summary>
        force_approve_collection = 29,
        
        /// <summary>
        /// >> force_freeze
        /// Same as [`freeze`](Self::freeze), but it is callable by [`Config::ForceOrigin`]
        /// </summary>
        force_freeze = 30,
        
        /// <summary>
        /// >> force_set_next_collection_id
        /// Sets [`NextCollectionId`] to `value`. Only callable by [`Config::ForceOrigin`].
        /// </summary>
        force_set_next_collection_id = 31,
        
        /// <summary>
        /// >> force_set_ethereum_account
        /// Sets [`ClaimableCollectionIds`] to `value`. Only callable by [`Config::ForceOrigin`].
        /// </summary>
        force_set_ethereum_account = 34,
        
        /// <summary>
        /// >> force_set_ethereum_collection_id
        /// Sets [`NativeCollectionIds`] to `native_collection_id`. Only callable by
        /// [`Config::ForceOrigin`].
        /// </summary>
        force_set_ethereum_collection_id = 35,
        
        /// <summary>
        /// >> force_set_unmintable_token_ids
        /// Sets [`UnmintableTokenIds`] storage. Only callable by
        /// [`Config::ForceOrigin`].
        /// </summary>
        force_set_unmintable_token_ids = 38,
        
        /// <summary>
        /// >> force_create_ethereum_collection
        /// Creates a new collection from `descriptor` at `collection_id`, origin must be
        /// [`Config::EthereumMigrationOrigin`]. It differs from `force_create_collection`
        /// since it writes to `NativeCollectionIds` and `ClaimableCollectionIds`.
        /// 
        /// # Params
        /// - `owner` - the account that will own the new collection
        /// - `claimer` - the ethereum address that will be able to claim the collection
        /// - `ethereum_collection_id` - the collection id on ethereum
        /// 
        /// # Errors
        /// - [`Error::DepositReserveFailed`] if the deposit cannot be reserved
        /// - [`Error::CollectionIdAlreadyInUse`] if the collection id is already in use
        /// </summary>
        force_create_ethereum_collection = 39,
        
        /// <summary>
        /// >> force_set_ethereum_unmintable_token_ids
        /// Sets [`UnmintableTokenIds`] using ethereum_collection_id, the function will fail if the
        /// ethereum_collection_id is invalid
        /// </summary>
        force_set_ethereum_unmintable_token_ids = 40,
    }
    
    /// <summary>
    /// >> 511 - Variant[pallet_multi_tokens.pallet.Call]
    /// Contains one variant per dispatchable that can be called by an extrinsic.
    /// </summary>
    public sealed class EnumCall : BaseEnumExt<Call, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.DefaultCollectionDescriptor, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.DefaultCollectionMutation>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.token.DefaultTokenMutation>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.mint.EnumDefaultMintParams>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.burn.DefaultBurnParams>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.transfer.EnumDefaultTransferParams>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.types.Freeze, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.types.Freeze, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT8, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT9>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT8>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Primitive.U32>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT17>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT18>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT16>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32>>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.DefaultCollectionMutation>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.transfer.EnumDefaultTransferParams>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.Collection>>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.token.Token>>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT8, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.attribute.Attribute>>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_multi_tokens.features.collection.types.CollectionAccount>>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.pallet_multi_tokens.features.token.types.TokenAccount>>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.DefaultCollectionDescriptor>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress>, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.mint.EnumFlexibleMintParams, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress>>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.policy.burn.DefaultBurnParams>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_runtime.multiaddress.EnumMultiAddress, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U32>>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.types.Freeze, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.ecdsa.Signature, Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U32>>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.ecdsa.Signature, Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.Enjin.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT19>>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.NetApi.Model.Types.Primitive.U128>>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160>, BaseVoid, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U64>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U64>>, BaseTuple<Substrate.Enjin.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Enjin.NET.NetApiExt.Generated.Model.primitive_types.H160, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.Enjin.NET.NetApiExt.Generated.Model.ep_multi_tokens.collection.DefaultCollectionDescriptor>, BaseTuple<Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U128>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U64>, Substrate.NetApi.Model.Types.Base.BaseCom<Substrate.NetApi.Model.Types.Primitive.U64>>>
    {
    }
}
