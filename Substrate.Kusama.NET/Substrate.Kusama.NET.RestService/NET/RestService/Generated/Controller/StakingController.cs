//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Microsoft.AspNetCore.Mvc;
using Substrate.Kusama.NET.RestService.Generated.Storage;
using Substrate.NetApi.Model.Types.Base;
using Substrate.ServiceLayer.Attributes;
using System.Collections.Generic;
using System.Threading.Tasks;


namespace Substrate.Kusama.NET.RestService.Generated.Controller
{
    
    
    /// <summary>
    /// StakingController controller to access storages.
    /// </summary>
    [ApiController()]
    [Route("[controller]")]
    public sealed class StakingController : ControllerBase
    {
        
        private IStakingStorage _stakingStorage;
        
        /// <summary>
        /// StakingController constructor.
        /// </summary>
        public StakingController(IStakingStorage stakingStorage)
        {
            _stakingStorage = stakingStorage;
        }
        
        /// <summary>
        /// >> ValidatorCount
        ///  The ideal number of active validators.
        /// </summary>
        [HttpGet("ValidatorCount")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U32), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ValidatorCountParams")]
        public IActionResult GetValidatorCount()
        {
            return this.Ok(_stakingStorage.GetValidatorCount());
        }
        
        /// <summary>
        /// >> MinimumValidatorCount
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        [HttpGet("MinimumValidatorCount")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U32), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "MinimumValidatorCountParams")]
        public IActionResult GetMinimumValidatorCount()
        {
            return this.Ok(_stakingStorage.GetMinimumValidatorCount());
        }
        
        /// <summary>
        /// >> Invulnerables
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        [HttpGet("Invulnerables")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "InvulnerablesParams")]
        public IActionResult GetInvulnerables()
        {
            return this.Ok(_stakingStorage.GetInvulnerables());
        }
        
        /// <summary>
        /// >> Bonded
        ///  Map from all locked "stash" accounts to the controller account.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        [HttpGet("Bonded")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "BondedParams", typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32))]
        public IActionResult GetBonded(string key)
        {
            return this.Ok(_stakingStorage.GetBonded(key));
        }
        
        /// <summary>
        /// >> MinNominatorBond
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        [HttpGet("MinNominatorBond")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U128), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "MinNominatorBondParams")]
        public IActionResult GetMinNominatorBond()
        {
            return this.Ok(_stakingStorage.GetMinNominatorBond());
        }
        
        /// <summary>
        /// >> MinValidatorBond
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        [HttpGet("MinValidatorBond")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U128), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "MinValidatorBondParams")]
        public IActionResult GetMinValidatorBond()
        {
            return this.Ok(_stakingStorage.GetMinValidatorBond());
        }
        
        /// <summary>
        /// >> MinimumActiveStake
        ///  The minimum active nominator stake of the last successful election.
        /// </summary>
        [HttpGet("MinimumActiveStake")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U128), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "MinimumActiveStakeParams")]
        public IActionResult GetMinimumActiveStake()
        {
            return this.Ok(_stakingStorage.GetMinimumActiveStake());
        }
        
        /// <summary>
        /// >> MinCommission
        ///  The minimum amount of commission that validators can set.
        /// 
        ///  If set to `0`, no limit exists.
        /// </summary>
        [HttpGet("MinCommission")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "MinCommissionParams")]
        public IActionResult GetMinCommission()
        {
            return this.Ok(_stakingStorage.GetMinCommission());
        }
        
        /// <summary>
        /// >> Ledger
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// </summary>
        [HttpGet("Ledger")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.StakingLedger), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "LedgerParams", typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32))]
        public IActionResult GetLedger(string key)
        {
            return this.Ok(_stakingStorage.GetLedger(key));
        }
        
        /// <summary>
        /// >> Payee
        ///  Where the reward payment should be made. Keyed by stash.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        [HttpGet("Payee")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumRewardDestination), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "PayeeParams", typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32))]
        public IActionResult GetPayee(string key)
        {
            return this.Ok(_stakingStorage.GetPayee(key));
        }
        
        /// <summary>
        /// >> Validators
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        [HttpGet("Validators")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ValidatorsParams", typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32))]
        public IActionResult GetValidators(string key)
        {
            return this.Ok(_stakingStorage.GetValidators(key));
        }
        
        /// <summary>
        /// >> CounterForValidators
        /// Counter for the related counted storage map
        /// </summary>
        [HttpGet("CounterForValidators")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U32), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "CounterForValidatorsParams")]
        public IActionResult GetCounterForValidators()
        {
            return this.Ok(_stakingStorage.GetCounterForValidators());
        }
        
        /// <summary>
        /// >> MaxValidatorsCount
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        [HttpGet("MaxValidatorsCount")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U32), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "MaxValidatorsCountParams")]
        public IActionResult GetMaxValidatorsCount()
        {
            return this.Ok(_stakingStorage.GetMaxValidatorsCount());
        }
        
        /// <summary>
        /// >> Nominators
        ///  The map from nominator stash key to their nomination preferences, namely the validators that
        ///  they wish to support.
        /// 
        ///  Note that the keys of this storage map might become non-decodable in case the
        ///  account's [`NominationsQuota::MaxNominations`] configuration is decreased.
        ///  In this rare case, these nominators
        ///  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        ///  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        ///  nominators will effectively not-exist, until they re-submit their preferences such that it
        ///  is within the bounds of the newly set `Config::MaxNominations`.
        /// 
        ///  This implies that `::iter_keys().count()` and `::iter().count()` might return different
        ///  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        ///  number of keys that exist.
        /// 
        ///  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        ///  [`Call::chill_other`] dispatchable by anyone.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        [HttpGet("Nominators")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.Nominations), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "NominatorsParams", typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32))]
        public IActionResult GetNominators(string key)
        {
            return this.Ok(_stakingStorage.GetNominators(key));
        }
        
        /// <summary>
        /// >> CounterForNominators
        /// Counter for the related counted storage map
        /// </summary>
        [HttpGet("CounterForNominators")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U32), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "CounterForNominatorsParams")]
        public IActionResult GetCounterForNominators()
        {
            return this.Ok(_stakingStorage.GetCounterForNominators());
        }
        
        /// <summary>
        /// >> MaxNominatorsCount
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        [HttpGet("MaxNominatorsCount")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U32), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "MaxNominatorsCountParams")]
        public IActionResult GetMaxNominatorsCount()
        {
            return this.Ok(_stakingStorage.GetMaxNominatorsCount());
        }
        
        /// <summary>
        /// >> CurrentEra
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        [HttpGet("CurrentEra")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U32), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "CurrentEraParams")]
        public IActionResult GetCurrentEra()
        {
            return this.Ok(_stakingStorage.GetCurrentEra());
        }
        
        /// <summary>
        /// >> ActiveEra
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        [HttpGet("ActiveEra")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ActiveEraInfo), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ActiveEraParams")]
        public IActionResult GetActiveEra()
        {
            return this.Ok(_stakingStorage.GetActiveEra());
        }
        
        /// <summary>
        /// >> ErasStartSessionIndex
        ///  The session index at which the era start for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        [HttpGet("ErasStartSessionIndex")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U32), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ErasStartSessionIndexParams", typeof(Substrate.NetApi.Model.Types.Primitive.U32))]
        public IActionResult GetErasStartSessionIndex(string key)
        {
            return this.Ok(_stakingStorage.GetErasStartSessionIndex(key));
        }
        
        /// <summary>
        /// >> ErasStakers
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        [HttpGet("ErasStakers")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.Exposure), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ErasStakersParams", typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>))]
        public IActionResult GetErasStakers(string key)
        {
            return this.Ok(_stakingStorage.GetErasStakers(key));
        }
        
        /// <summary>
        /// >> ErasStakersClipped
        ///  Clipped Exposure of validator at era.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxNominatorRewardedPerValidator` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// </summary>
        [HttpGet("ErasStakersClipped")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.Exposure), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ErasStakersClippedParams", typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>))]
        public IActionResult GetErasStakersClipped(string key)
        {
            return this.Ok(_stakingStorage.GetErasStakersClipped(key));
        }
        
        /// <summary>
        /// >> ErasValidatorPrefs
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after `HISTORY_DEPTH` eras.
        /// </summary>
        [HttpGet("ErasValidatorPrefs")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ErasValidatorPrefsParams", typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>))]
        public IActionResult GetErasValidatorPrefs(string key)
        {
            return this.Ok(_stakingStorage.GetErasValidatorPrefs(key));
        }
        
        /// <summary>
        /// >> ErasValidatorReward
        ///  The total validator era payout for the last `HISTORY_DEPTH` eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        [HttpGet("ErasValidatorReward")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U128), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ErasValidatorRewardParams", typeof(Substrate.NetApi.Model.Types.Primitive.U32))]
        public IActionResult GetErasValidatorReward(string key)
        {
            return this.Ok(_stakingStorage.GetErasValidatorReward(key));
        }
        
        /// <summary>
        /// >> ErasRewardPoints
        ///  Rewards for the last `HISTORY_DEPTH` eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        [HttpGet("ErasRewardPoints")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EraRewardPoints), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ErasRewardPointsParams", typeof(Substrate.NetApi.Model.Types.Primitive.U32))]
        public IActionResult GetErasRewardPoints(string key)
        {
            return this.Ok(_stakingStorage.GetErasRewardPoints(key));
        }
        
        /// <summary>
        /// >> ErasTotalStake
        ///  The total amount staked for the last `HISTORY_DEPTH` eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        [HttpGet("ErasTotalStake")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U128), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ErasTotalStakeParams", typeof(Substrate.NetApi.Model.Types.Primitive.U32))]
        public IActionResult GetErasTotalStake(string key)
        {
            return this.Ok(_stakingStorage.GetErasTotalStake(key));
        }
        
        /// <summary>
        /// >> ForceEra
        ///  Mode of era forcing.
        /// </summary>
        [HttpGet("ForceEra")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumForcing), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ForceEraParams")]
        public IActionResult GetForceEra()
        {
            return this.Ok(_stakingStorage.GetForceEra());
        }
        
        /// <summary>
        /// >> SlashRewardFraction
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        [HttpGet("SlashRewardFraction")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "SlashRewardFractionParams")]
        public IActionResult GetSlashRewardFraction()
        {
            return this.Ok(_stakingStorage.GetSlashRewardFraction());
        }
        
        /// <summary>
        /// >> CanceledSlashPayout
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        [HttpGet("CanceledSlashPayout")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U128), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "CanceledSlashPayoutParams")]
        public IActionResult GetCanceledSlashPayout()
        {
            return this.Ok(_stakingStorage.GetCanceledSlashPayout());
        }
        
        /// <summary>
        /// >> UnappliedSlashes
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        [HttpGet("UnappliedSlashes")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.UnappliedSlash>), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "UnappliedSlashesParams", typeof(Substrate.NetApi.Model.Types.Primitive.U32))]
        public IActionResult GetUnappliedSlashes(string key)
        {
            return this.Ok(_stakingStorage.GetUnappliedSlashes(key));
        }
        
        /// <summary>
        /// >> BondedEras
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        [HttpGet("BondedEras")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "BondedErasParams")]
        public IActionResult GetBondedEras()
        {
            return this.Ok(_stakingStorage.GetBondedEras());
        }
        
        /// <summary>
        /// >> ValidatorSlashInEra
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        [HttpGet("ValidatorSlashInEra")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ValidatorSlashInEraParams", typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>))]
        public IActionResult GetValidatorSlashInEra(string key)
        {
            return this.Ok(_stakingStorage.GetValidatorSlashInEra(key));
        }
        
        /// <summary>
        /// >> NominatorSlashInEra
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        [HttpGet("NominatorSlashInEra")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U128), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "NominatorSlashInEraParams", typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>))]
        public IActionResult GetNominatorSlashInEra(string key)
        {
            return this.Ok(_stakingStorage.GetNominatorSlashInEra(key));
        }
        
        /// <summary>
        /// >> SlashingSpans
        ///  Slashing spans for stash accounts.
        /// </summary>
        [HttpGet("SlashingSpans")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SlashingSpans), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "SlashingSpansParams", typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32))]
        public IActionResult GetSlashingSpans(string key)
        {
            return this.Ok(_stakingStorage.GetSlashingSpans(key));
        }
        
        /// <summary>
        /// >> SpanSlash
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        [HttpGet("SpanSlash")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SpanRecord), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "SpanSlashParams", typeof(Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.NetApi.Model.Types.Primitive.U32>))]
        public IActionResult GetSpanSlash(string key)
        {
            return this.Ok(_stakingStorage.GetSpanSlash(key));
        }
        
        /// <summary>
        /// >> CurrentPlannedSession
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        [HttpGet("CurrentPlannedSession")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Primitive.U32), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "CurrentPlannedSessionParams")]
        public IActionResult GetCurrentPlannedSession()
        {
            return this.Ok(_stakingStorage.GetCurrentPlannedSession());
        }
        
        /// <summary>
        /// >> OffendingValidators
        ///  Indices of validators that have offended in the active era and whether they are currently
        ///  disabled.
        /// 
        ///  This value should be a superset of disabled validators since not all offences lead to the
        ///  validator being disabled (if there was no slash). This is needed to track the percentage of
        ///  validators that have offended in the current era, ensuring a new era is forced if
        ///  `OffendingValidatorsThreshold` is reached. The vec is always kept sorted so that we can find
        ///  whether a given validator has previously offended using binary search. It gets cleared when
        ///  the era ends.
        /// </summary>
        [HttpGet("OffendingValidators")]
        [ProducesResponseType(typeof(Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.Bool>>), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "OffendingValidatorsParams")]
        public IActionResult GetOffendingValidators()
        {
            return this.Ok(_stakingStorage.GetOffendingValidators());
        }
        
        /// <summary>
        /// >> ChillThreshold
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        [HttpGet("ChillThreshold")]
        [ProducesResponseType(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent), 200)]
        [StorageKeyBuilder(typeof(Substrate.Kusama.NET.NetApiExt.Generated.Storage.StakingStorage), "ChillThresholdParams")]
        public IActionResult GetChillThreshold()
        {
            return this.Ok(_stakingStorage.GetChillThreshold());
        }
    }
}
