//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using Substrate.ServiceLayer.Attributes;
using Substrate.ServiceLayer.Storage;
using System.Collections.Generic;
using System.Threading.Tasks;


namespace Substrate.Kusama.NET.RestService.Generated.Storage
{
    
    
    /// <summary>
    /// IStakingStorage interface definition.
    /// </summary>
    public interface IStakingStorage : IStorage
    {
        
        /// <summary>
        /// >> ValidatorCount
        ///  The ideal number of active validators.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U32 GetValidatorCount();
        
        /// <summary>
        /// >> MinimumValidatorCount
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U32 GetMinimumValidatorCount();
        
        /// <summary>
        /// >> Invulnerables
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> GetInvulnerables();
        
        /// <summary>
        /// >> Bonded
        ///  Map from all locked "stash" accounts to the controller account.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 GetBonded(string key);
        
        /// <summary>
        /// >> MinNominatorBond
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U128 GetMinNominatorBond();
        
        /// <summary>
        /// >> MinValidatorBond
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U128 GetMinValidatorBond();
        
        /// <summary>
        /// >> MinimumActiveStake
        ///  The minimum active nominator stake of the last successful election.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U128 GetMinimumActiveStake();
        
        /// <summary>
        /// >> MinCommission
        ///  The minimum amount of commission that validators can set.
        /// 
        ///  If set to `0`, no limit exists.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill GetMinCommission();
        
        /// <summary>
        /// >> Ledger
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// 
        ///  Note: All the reads and mutations to this storage *MUST* be done through the methods exposed
        ///  by [`StakingLedger`] to ensure data and lock consistency.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.StakingLedger GetLedger(string key);
        
        /// <summary>
        /// >> Payee
        ///  Where the reward payment should be made. Keyed by stash.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumRewardDestination GetPayee(string key);
        
        /// <summary>
        /// >> Validators
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs GetValidators(string key);
        
        /// <summary>
        /// >> CounterForValidators
        /// Counter for the related counted storage map
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U32 GetCounterForValidators();
        
        /// <summary>
        /// >> MaxValidatorsCount
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U32 GetMaxValidatorsCount();
        
        /// <summary>
        /// >> Nominators
        ///  The map from nominator stash key to their nomination preferences, namely the validators that
        ///  they wish to support.
        /// 
        ///  Note that the keys of this storage map might become non-decodable in case the
        ///  account's [`NominationsQuota::MaxNominations`] configuration is decreased.
        ///  In this rare case, these nominators
        ///  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        ///  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        ///  nominators will effectively not-exist, until they re-submit their preferences such that it
        ///  is within the bounds of the newly set `Config::MaxNominations`.
        /// 
        ///  This implies that `::iter_keys().count()` and `::iter().count()` might return different
        ///  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        ///  number of keys that exist.
        /// 
        ///  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        ///  [`Call::chill_other`] dispatchable by anyone.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.Nominations GetNominators(string key);
        
        /// <summary>
        /// >> CounterForNominators
        /// Counter for the related counted storage map
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U32 GetCounterForNominators();
        
        /// <summary>
        /// >> VirtualStakers
        ///  Stakers whose funds are managed by other pallets.
        /// 
        ///  This pallet does not apply any locks on them, therefore they are only virtually bonded. They
        ///  are expected to be keyless accounts and hence should not be allowed to mutate their ledger
        ///  directly via this pallet. Instead, these accounts are managed by other pallets and accessed
        ///  via low level apis. We keep track of them to do minimal integrity checks.
        /// </summary>
        Substrate.NetApi.Model.Types.Base.BaseTuple GetVirtualStakers(string key);
        
        /// <summary>
        /// >> CounterForVirtualStakers
        /// Counter for the related counted storage map
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U32 GetCounterForVirtualStakers();
        
        /// <summary>
        /// >> MaxNominatorsCount
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U32 GetMaxNominatorsCount();
        
        /// <summary>
        /// >> CurrentEra
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U32 GetCurrentEra();
        
        /// <summary>
        /// >> ActiveEra
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ActiveEraInfo GetActiveEra();
        
        /// <summary>
        /// >> ErasStartSessionIndex
        ///  The session index at which the era start for the last [`Config::HistoryDepth`] eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U32 GetErasStartSessionIndex(string key);
        
        /// <summary>
        /// >> ErasStakers
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// 
        ///  Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure GetErasStakers(string key);
        
        /// <summary>
        /// >> ErasStakersOverview
        ///  Summary of validator exposure at a given era.
        /// 
        ///  This contains the total stake in support of the validator and their own stake. In addition,
        ///  it can also be used to get the number of nominators backing this validator and the number of
        ///  exposure pages they are divided into. The page count is useful to determine the number of
        ///  pages of rewards that needs to be claimed.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        ///  Should only be accessed through `EraInfo`.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty overview is returned.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.PagedExposureMetadata GetErasStakersOverview(string key);
        
        /// <summary>
        /// >> ErasStakersClipped
        ///  Clipped Exposure of validator at era.
        /// 
        ///  Note: This is deprecated, should be used as read-only and will be removed in the future.
        ///  New `Exposure`s are stored in a paged manner in `ErasStakersPaged` instead.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxExposurePageSize` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  It is removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// 
        ///  Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure GetErasStakersClipped(string key);
        
        /// <summary>
        /// >> ErasStakersPaged
        ///  Paginated exposure of a validator at given era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion, then stash account and finally
        ///  the page. Should only be accessed through `EraInfo`.
        /// 
        ///  This is cleared after [`Config::HistoryDepth`] eras.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.ExposurePage GetErasStakersPaged(string key);
        
        /// <summary>
        /// >> ClaimedRewards
        ///  History of claimed paged rewards by era and validator.
        /// 
        ///  This is keyed by era and validator stash which maps to the set of page indexes which have
        ///  been claimed.
        /// 
        ///  It is removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32> GetClaimedRewards(string key);
        
        /// <summary>
        /// >> ErasValidatorPrefs
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs GetErasValidatorPrefs(string key);
        
        /// <summary>
        /// >> ErasValidatorReward
        ///  The total validator era payout for the last [`Config::HistoryDepth`] eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U128 GetErasValidatorReward(string key);
        
        /// <summary>
        /// >> ErasRewardPoints
        ///  Rewards for the last [`Config::HistoryDepth`] eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EraRewardPoints GetErasRewardPoints(string key);
        
        /// <summary>
        /// >> ErasTotalStake
        ///  The total amount staked for the last [`Config::HistoryDepth`] eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U128 GetErasTotalStake(string key);
        
        /// <summary>
        /// >> ForceEra
        ///  Mode of era forcing.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumForcing GetForceEra();
        
        /// <summary>
        /// >> MaxStakedRewards
        ///  Maximum staked rewards, i.e. the percentage of the era inflation that
        ///  is used for stake rewards.
        ///  See [Era payout](./index.html#era-payout).
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent GetMaxStakedRewards();
        
        /// <summary>
        /// >> SlashRewardFraction
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill GetSlashRewardFraction();
        
        /// <summary>
        /// >> CanceledSlashPayout
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U128 GetCanceledSlashPayout();
        
        /// <summary>
        /// >> UnappliedSlashes
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.UnappliedSlash> GetUnappliedSlashes(string key);
        
        /// <summary>
        /// >> BondedEras
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>> GetBondedEras();
        
        /// <summary>
        /// >> ValidatorSlashInEra
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128> GetValidatorSlashInEra(string key);
        
        /// <summary>
        /// >> NominatorSlashInEra
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U128 GetNominatorSlashInEra(string key);
        
        /// <summary>
        /// >> SlashingSpans
        ///  Slashing spans for stash accounts.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SlashingSpans GetSlashingSpans(string key);
        
        /// <summary>
        /// >> SpanSlash
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SpanRecord GetSpanSlash(string key);
        
        /// <summary>
        /// >> CurrentPlannedSession
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U32 GetCurrentPlannedSession();
        
        /// <summary>
        /// >> DisabledValidators
        ///  Indices of validators that have offended in the active era. The offenders are disabled for a
        ///  whole era. For this reason they are kept here - only staking pallet knows about eras. The
        ///  implementor of [`DisablingStrategy`] defines if a validator should be disabled which
        ///  implicitly means that the implementor also controls the max number of disabled validators.
        /// 
        ///  The vec is always kept sorted so that we can find whether a given validator has previously
        ///  offended using binary search.
        /// </summary>
        Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32> GetDisabledValidators();
        
        /// <summary>
        /// >> ChillThreshold
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent GetChillThreshold();
    }
    
    /// <summary>
    /// StakingStorage class definition.
    /// </summary>
    public sealed class StakingStorage : IStakingStorage
    {
        
        /// <summary>
        /// _validatorCountTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> _validatorCountTypedStorage;
        
        /// <summary>
        /// _minimumValidatorCountTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> _minimumValidatorCountTypedStorage;
        
        /// <summary>
        /// _invulnerablesTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>> _invulnerablesTypedStorage;
        
        /// <summary>
        /// _bondedTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> _bondedTypedStorage;
        
        /// <summary>
        /// _minNominatorBondTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128> _minNominatorBondTypedStorage;
        
        /// <summary>
        /// _minValidatorBondTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128> _minValidatorBondTypedStorage;
        
        /// <summary>
        /// _minimumActiveStakeTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128> _minimumActiveStakeTypedStorage;
        
        /// <summary>
        /// _minCommissionTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill> _minCommissionTypedStorage;
        
        /// <summary>
        /// _ledgerTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.StakingLedger> _ledgerTypedStorage;
        
        /// <summary>
        /// _payeeTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumRewardDestination> _payeeTypedStorage;
        
        /// <summary>
        /// _validatorsTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs> _validatorsTypedStorage;
        
        /// <summary>
        /// _counterForValidatorsTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> _counterForValidatorsTypedStorage;
        
        /// <summary>
        /// _maxValidatorsCountTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> _maxValidatorsCountTypedStorage;
        
        /// <summary>
        /// _nominatorsTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.Nominations> _nominatorsTypedStorage;
        
        /// <summary>
        /// _counterForNominatorsTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> _counterForNominatorsTypedStorage;
        
        /// <summary>
        /// _virtualStakersTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple> _virtualStakersTypedStorage;
        
        /// <summary>
        /// _counterForVirtualStakersTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> _counterForVirtualStakersTypedStorage;
        
        /// <summary>
        /// _maxNominatorsCountTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> _maxNominatorsCountTypedStorage;
        
        /// <summary>
        /// _currentEraTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> _currentEraTypedStorage;
        
        /// <summary>
        /// _activeEraTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ActiveEraInfo> _activeEraTypedStorage;
        
        /// <summary>
        /// _erasStartSessionIndexTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U32> _erasStartSessionIndexTypedStorage;
        
        /// <summary>
        /// _erasStakersTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure> _erasStakersTypedStorage;
        
        /// <summary>
        /// _erasStakersOverviewTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.PagedExposureMetadata> _erasStakersOverviewTypedStorage;
        
        /// <summary>
        /// _erasStakersClippedTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure> _erasStakersClippedTypedStorage;
        
        /// <summary>
        /// _erasStakersPagedTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.ExposurePage> _erasStakersPagedTypedStorage;
        
        /// <summary>
        /// _claimedRewardsTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>> _claimedRewardsTypedStorage;
        
        /// <summary>
        /// _erasValidatorPrefsTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs> _erasValidatorPrefsTypedStorage;
        
        /// <summary>
        /// _erasValidatorRewardTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U128> _erasValidatorRewardTypedStorage;
        
        /// <summary>
        /// _erasRewardPointsTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EraRewardPoints> _erasRewardPointsTypedStorage;
        
        /// <summary>
        /// _erasTotalStakeTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U128> _erasTotalStakeTypedStorage;
        
        /// <summary>
        /// _forceEraTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumForcing> _forceEraTypedStorage;
        
        /// <summary>
        /// _maxStakedRewardsTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent> _maxStakedRewardsTypedStorage;
        
        /// <summary>
        /// _slashRewardFractionTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill> _slashRewardFractionTypedStorage;
        
        /// <summary>
        /// _canceledSlashPayoutTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128> _canceledSlashPayoutTypedStorage;
        
        /// <summary>
        /// _unappliedSlashesTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.UnappliedSlash>> _unappliedSlashesTypedStorage;
        
        /// <summary>
        /// _bondedErasTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>> _bondedErasTypedStorage;
        
        /// <summary>
        /// _validatorSlashInEraTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>> _validatorSlashInEraTypedStorage;
        
        /// <summary>
        /// _nominatorSlashInEraTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U128> _nominatorSlashInEraTypedStorage;
        
        /// <summary>
        /// _slashingSpansTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SlashingSpans> _slashingSpansTypedStorage;
        
        /// <summary>
        /// _spanSlashTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SpanRecord> _spanSlashTypedStorage;
        
        /// <summary>
        /// _currentPlannedSessionTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> _currentPlannedSessionTypedStorage;
        
        /// <summary>
        /// _disabledValidatorsTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>> _disabledValidatorsTypedStorage;
        
        /// <summary>
        /// _chillThresholdTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent> _chillThresholdTypedStorage;
        
        /// <summary>
        /// StakingStorage constructor.
        /// </summary>
        public StakingStorage(IStorageDataProvider storageDataProvider, List<IStorageChangeDelegate> storageChangeDelegates)
        {
            this.ValidatorCountTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32>("Staking.ValidatorCount", storageDataProvider, storageChangeDelegates);
            this.MinimumValidatorCountTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32>("Staking.MinimumValidatorCount", storageDataProvider, storageChangeDelegates);
            this.InvulnerablesTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>>("Staking.Invulnerables", storageDataProvider, storageChangeDelegates);
            this.BondedTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>("Staking.Bonded", storageDataProvider, storageChangeDelegates);
            this.MinNominatorBondTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128>("Staking.MinNominatorBond", storageDataProvider, storageChangeDelegates);
            this.MinValidatorBondTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128>("Staking.MinValidatorBond", storageDataProvider, storageChangeDelegates);
            this.MinimumActiveStakeTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128>("Staking.MinimumActiveStake", storageDataProvider, storageChangeDelegates);
            this.MinCommissionTypedStorage = new TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill>("Staking.MinCommission", storageDataProvider, storageChangeDelegates);
            this.LedgerTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.StakingLedger>("Staking.Ledger", storageDataProvider, storageChangeDelegates);
            this.PayeeTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumRewardDestination>("Staking.Payee", storageDataProvider, storageChangeDelegates);
            this.ValidatorsTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs>("Staking.Validators", storageDataProvider, storageChangeDelegates);
            this.CounterForValidatorsTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32>("Staking.CounterForValidators", storageDataProvider, storageChangeDelegates);
            this.MaxValidatorsCountTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32>("Staking.MaxValidatorsCount", storageDataProvider, storageChangeDelegates);
            this.NominatorsTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.Nominations>("Staking.Nominators", storageDataProvider, storageChangeDelegates);
            this.CounterForNominatorsTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32>("Staking.CounterForNominators", storageDataProvider, storageChangeDelegates);
            this.VirtualStakersTypedStorage = new TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple>("Staking.VirtualStakers", storageDataProvider, storageChangeDelegates);
            this.CounterForVirtualStakersTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32>("Staking.CounterForVirtualStakers", storageDataProvider, storageChangeDelegates);
            this.MaxNominatorsCountTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32>("Staking.MaxNominatorsCount", storageDataProvider, storageChangeDelegates);
            this.CurrentEraTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32>("Staking.CurrentEra", storageDataProvider, storageChangeDelegates);
            this.ActiveEraTypedStorage = new TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ActiveEraInfo>("Staking.ActiveEra", storageDataProvider, storageChangeDelegates);
            this.ErasStartSessionIndexTypedStorage = new TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U32>("Staking.ErasStartSessionIndex", storageDataProvider, storageChangeDelegates);
            this.ErasStakersTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure>("Staking.ErasStakers", storageDataProvider, storageChangeDelegates);
            this.ErasStakersOverviewTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.PagedExposureMetadata>("Staking.ErasStakersOverview", storageDataProvider, storageChangeDelegates);
            this.ErasStakersClippedTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure>("Staking.ErasStakersClipped", storageDataProvider, storageChangeDelegates);
            this.ErasStakersPagedTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.ExposurePage>("Staking.ErasStakersPaged", storageDataProvider, storageChangeDelegates);
            this.ClaimedRewardsTypedStorage = new TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>>("Staking.ClaimedRewards", storageDataProvider, storageChangeDelegates);
            this.ErasValidatorPrefsTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs>("Staking.ErasValidatorPrefs", storageDataProvider, storageChangeDelegates);
            this.ErasValidatorRewardTypedStorage = new TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U128>("Staking.ErasValidatorReward", storageDataProvider, storageChangeDelegates);
            this.ErasRewardPointsTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EraRewardPoints>("Staking.ErasRewardPoints", storageDataProvider, storageChangeDelegates);
            this.ErasTotalStakeTypedStorage = new TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U128>("Staking.ErasTotalStake", storageDataProvider, storageChangeDelegates);
            this.ForceEraTypedStorage = new TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumForcing>("Staking.ForceEra", storageDataProvider, storageChangeDelegates);
            this.MaxStakedRewardsTypedStorage = new TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent>("Staking.MaxStakedRewards", storageDataProvider, storageChangeDelegates);
            this.SlashRewardFractionTypedStorage = new TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill>("Staking.SlashRewardFraction", storageDataProvider, storageChangeDelegates);
            this.CanceledSlashPayoutTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128>("Staking.CanceledSlashPayout", storageDataProvider, storageChangeDelegates);
            this.UnappliedSlashesTypedStorage = new TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.UnappliedSlash>>("Staking.UnappliedSlashes", storageDataProvider, storageChangeDelegates);
            this.BondedErasTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>>("Staking.BondedEras", storageDataProvider, storageChangeDelegates);
            this.ValidatorSlashInEraTypedStorage = new TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>>("Staking.ValidatorSlashInEra", storageDataProvider, storageChangeDelegates);
            this.NominatorSlashInEraTypedStorage = new TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U128>("Staking.NominatorSlashInEra", storageDataProvider, storageChangeDelegates);
            this.SlashingSpansTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SlashingSpans>("Staking.SlashingSpans", storageDataProvider, storageChangeDelegates);
            this.SpanSlashTypedStorage = new TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SpanRecord>("Staking.SpanSlash", storageDataProvider, storageChangeDelegates);
            this.CurrentPlannedSessionTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32>("Staking.CurrentPlannedSession", storageDataProvider, storageChangeDelegates);
            this.DisabledValidatorsTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>>("Staking.DisabledValidators", storageDataProvider, storageChangeDelegates);
            this.ChillThresholdTypedStorage = new TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent>("Staking.ChillThreshold", storageDataProvider, storageChangeDelegates);
        }
        
        /// <summary>
        /// _validatorCountTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> ValidatorCountTypedStorage
        {
            get
            {
                return _validatorCountTypedStorage;
            }
            set
            {
                _validatorCountTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _minimumValidatorCountTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> MinimumValidatorCountTypedStorage
        {
            get
            {
                return _minimumValidatorCountTypedStorage;
            }
            set
            {
                _minimumValidatorCountTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _invulnerablesTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>> InvulnerablesTypedStorage
        {
            get
            {
                return _invulnerablesTypedStorage;
            }
            set
            {
                _invulnerablesTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _bondedTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> BondedTypedStorage
        {
            get
            {
                return _bondedTypedStorage;
            }
            set
            {
                _bondedTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _minNominatorBondTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128> MinNominatorBondTypedStorage
        {
            get
            {
                return _minNominatorBondTypedStorage;
            }
            set
            {
                _minNominatorBondTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _minValidatorBondTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128> MinValidatorBondTypedStorage
        {
            get
            {
                return _minValidatorBondTypedStorage;
            }
            set
            {
                _minValidatorBondTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _minimumActiveStakeTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128> MinimumActiveStakeTypedStorage
        {
            get
            {
                return _minimumActiveStakeTypedStorage;
            }
            set
            {
                _minimumActiveStakeTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _minCommissionTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill> MinCommissionTypedStorage
        {
            get
            {
                return _minCommissionTypedStorage;
            }
            set
            {
                _minCommissionTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _ledgerTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.StakingLedger> LedgerTypedStorage
        {
            get
            {
                return _ledgerTypedStorage;
            }
            set
            {
                _ledgerTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _payeeTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumRewardDestination> PayeeTypedStorage
        {
            get
            {
                return _payeeTypedStorage;
            }
            set
            {
                _payeeTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _validatorsTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs> ValidatorsTypedStorage
        {
            get
            {
                return _validatorsTypedStorage;
            }
            set
            {
                _validatorsTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _counterForValidatorsTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> CounterForValidatorsTypedStorage
        {
            get
            {
                return _counterForValidatorsTypedStorage;
            }
            set
            {
                _counterForValidatorsTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _maxValidatorsCountTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> MaxValidatorsCountTypedStorage
        {
            get
            {
                return _maxValidatorsCountTypedStorage;
            }
            set
            {
                _maxValidatorsCountTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _nominatorsTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.Nominations> NominatorsTypedStorage
        {
            get
            {
                return _nominatorsTypedStorage;
            }
            set
            {
                _nominatorsTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _counterForNominatorsTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> CounterForNominatorsTypedStorage
        {
            get
            {
                return _counterForNominatorsTypedStorage;
            }
            set
            {
                _counterForNominatorsTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _virtualStakersTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple> VirtualStakersTypedStorage
        {
            get
            {
                return _virtualStakersTypedStorage;
            }
            set
            {
                _virtualStakersTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _counterForVirtualStakersTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> CounterForVirtualStakersTypedStorage
        {
            get
            {
                return _counterForVirtualStakersTypedStorage;
            }
            set
            {
                _counterForVirtualStakersTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _maxNominatorsCountTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> MaxNominatorsCountTypedStorage
        {
            get
            {
                return _maxNominatorsCountTypedStorage;
            }
            set
            {
                _maxNominatorsCountTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _currentEraTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> CurrentEraTypedStorage
        {
            get
            {
                return _currentEraTypedStorage;
            }
            set
            {
                _currentEraTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _activeEraTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ActiveEraInfo> ActiveEraTypedStorage
        {
            get
            {
                return _activeEraTypedStorage;
            }
            set
            {
                _activeEraTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _erasStartSessionIndexTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U32> ErasStartSessionIndexTypedStorage
        {
            get
            {
                return _erasStartSessionIndexTypedStorage;
            }
            set
            {
                _erasStartSessionIndexTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _erasStakersTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure> ErasStakersTypedStorage
        {
            get
            {
                return _erasStakersTypedStorage;
            }
            set
            {
                _erasStakersTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _erasStakersOverviewTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.PagedExposureMetadata> ErasStakersOverviewTypedStorage
        {
            get
            {
                return _erasStakersOverviewTypedStorage;
            }
            set
            {
                _erasStakersOverviewTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _erasStakersClippedTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure> ErasStakersClippedTypedStorage
        {
            get
            {
                return _erasStakersClippedTypedStorage;
            }
            set
            {
                _erasStakersClippedTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _erasStakersPagedTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.ExposurePage> ErasStakersPagedTypedStorage
        {
            get
            {
                return _erasStakersPagedTypedStorage;
            }
            set
            {
                _erasStakersPagedTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _claimedRewardsTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>> ClaimedRewardsTypedStorage
        {
            get
            {
                return _claimedRewardsTypedStorage;
            }
            set
            {
                _claimedRewardsTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _erasValidatorPrefsTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs> ErasValidatorPrefsTypedStorage
        {
            get
            {
                return _erasValidatorPrefsTypedStorage;
            }
            set
            {
                _erasValidatorPrefsTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _erasValidatorRewardTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U128> ErasValidatorRewardTypedStorage
        {
            get
            {
                return _erasValidatorRewardTypedStorage;
            }
            set
            {
                _erasValidatorRewardTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _erasRewardPointsTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EraRewardPoints> ErasRewardPointsTypedStorage
        {
            get
            {
                return _erasRewardPointsTypedStorage;
            }
            set
            {
                _erasRewardPointsTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _erasTotalStakeTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U128> ErasTotalStakeTypedStorage
        {
            get
            {
                return _erasTotalStakeTypedStorage;
            }
            set
            {
                _erasTotalStakeTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _forceEraTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumForcing> ForceEraTypedStorage
        {
            get
            {
                return _forceEraTypedStorage;
            }
            set
            {
                _forceEraTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _maxStakedRewardsTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent> MaxStakedRewardsTypedStorage
        {
            get
            {
                return _maxStakedRewardsTypedStorage;
            }
            set
            {
                _maxStakedRewardsTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _slashRewardFractionTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill> SlashRewardFractionTypedStorage
        {
            get
            {
                return _slashRewardFractionTypedStorage;
            }
            set
            {
                _slashRewardFractionTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _canceledSlashPayoutTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U128> CanceledSlashPayoutTypedStorage
        {
            get
            {
                return _canceledSlashPayoutTypedStorage;
            }
            set
            {
                _canceledSlashPayoutTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _unappliedSlashesTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.UnappliedSlash>> UnappliedSlashesTypedStorage
        {
            get
            {
                return _unappliedSlashesTypedStorage;
            }
            set
            {
                _unappliedSlashesTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _bondedErasTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>> BondedErasTypedStorage
        {
            get
            {
                return _bondedErasTypedStorage;
            }
            set
            {
                _bondedErasTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _validatorSlashInEraTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128>> ValidatorSlashInEraTypedStorage
        {
            get
            {
                return _validatorSlashInEraTypedStorage;
            }
            set
            {
                _validatorSlashInEraTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _nominatorSlashInEraTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.NetApi.Model.Types.Primitive.U128> NominatorSlashInEraTypedStorage
        {
            get
            {
                return _nominatorSlashInEraTypedStorage;
            }
            set
            {
                _nominatorSlashInEraTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _slashingSpansTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SlashingSpans> SlashingSpansTypedStorage
        {
            get
            {
                return _slashingSpansTypedStorage;
            }
            set
            {
                _slashingSpansTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _spanSlashTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SpanRecord> SpanSlashTypedStorage
        {
            get
            {
                return _spanSlashTypedStorage;
            }
            set
            {
                _spanSlashTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _currentPlannedSessionTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U32> CurrentPlannedSessionTypedStorage
        {
            get
            {
                return _currentPlannedSessionTypedStorage;
            }
            set
            {
                _currentPlannedSessionTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _disabledValidatorsTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32>> DisabledValidatorsTypedStorage
        {
            get
            {
                return _disabledValidatorsTypedStorage;
            }
            set
            {
                _disabledValidatorsTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _chillThresholdTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent> ChillThresholdTypedStorage
        {
            get
            {
                return _chillThresholdTypedStorage;
            }
            set
            {
                _chillThresholdTypedStorage = value;
            }
        }
        
        /// <summary>
        /// Connects to all storages and initializes the change subscription handling.
        /// </summary>
        public async Task InitializeAsync(Substrate.ServiceLayer.Storage.IStorageDataProvider dataProvider)
        {
            await ValidatorCountTypedStorage.InitializeAsync("Staking", "ValidatorCount");
            await MinimumValidatorCountTypedStorage.InitializeAsync("Staking", "MinimumValidatorCount");
            await InvulnerablesTypedStorage.InitializeAsync("Staking", "Invulnerables");
            await BondedTypedStorage.InitializeAsync("Staking", "Bonded");
            await MinNominatorBondTypedStorage.InitializeAsync("Staking", "MinNominatorBond");
            await MinValidatorBondTypedStorage.InitializeAsync("Staking", "MinValidatorBond");
            await MinimumActiveStakeTypedStorage.InitializeAsync("Staking", "MinimumActiveStake");
            await MinCommissionTypedStorage.InitializeAsync("Staking", "MinCommission");
            await LedgerTypedStorage.InitializeAsync("Staking", "Ledger");
            await PayeeTypedStorage.InitializeAsync("Staking", "Payee");
            await ValidatorsTypedStorage.InitializeAsync("Staking", "Validators");
            await CounterForValidatorsTypedStorage.InitializeAsync("Staking", "CounterForValidators");
            await MaxValidatorsCountTypedStorage.InitializeAsync("Staking", "MaxValidatorsCount");
            await NominatorsTypedStorage.InitializeAsync("Staking", "Nominators");
            await CounterForNominatorsTypedStorage.InitializeAsync("Staking", "CounterForNominators");
            await VirtualStakersTypedStorage.InitializeAsync("Staking", "VirtualStakers");
            await CounterForVirtualStakersTypedStorage.InitializeAsync("Staking", "CounterForVirtualStakers");
            await MaxNominatorsCountTypedStorage.InitializeAsync("Staking", "MaxNominatorsCount");
            await CurrentEraTypedStorage.InitializeAsync("Staking", "CurrentEra");
            await ActiveEraTypedStorage.InitializeAsync("Staking", "ActiveEra");
            await ErasStartSessionIndexTypedStorage.InitializeAsync("Staking", "ErasStartSessionIndex");
            await ErasStakersTypedStorage.InitializeAsync("Staking", "ErasStakers");
            await ErasStakersOverviewTypedStorage.InitializeAsync("Staking", "ErasStakersOverview");
            await ErasStakersClippedTypedStorage.InitializeAsync("Staking", "ErasStakersClipped");
            await ErasStakersPagedTypedStorage.InitializeAsync("Staking", "ErasStakersPaged");
            await ClaimedRewardsTypedStorage.InitializeAsync("Staking", "ClaimedRewards");
            await ErasValidatorPrefsTypedStorage.InitializeAsync("Staking", "ErasValidatorPrefs");
            await ErasValidatorRewardTypedStorage.InitializeAsync("Staking", "ErasValidatorReward");
            await ErasRewardPointsTypedStorage.InitializeAsync("Staking", "ErasRewardPoints");
            await ErasTotalStakeTypedStorage.InitializeAsync("Staking", "ErasTotalStake");
            await ForceEraTypedStorage.InitializeAsync("Staking", "ForceEra");
            await MaxStakedRewardsTypedStorage.InitializeAsync("Staking", "MaxStakedRewards");
            await SlashRewardFractionTypedStorage.InitializeAsync("Staking", "SlashRewardFraction");
            await CanceledSlashPayoutTypedStorage.InitializeAsync("Staking", "CanceledSlashPayout");
            await UnappliedSlashesTypedStorage.InitializeAsync("Staking", "UnappliedSlashes");
            await BondedErasTypedStorage.InitializeAsync("Staking", "BondedEras");
            await ValidatorSlashInEraTypedStorage.InitializeAsync("Staking", "ValidatorSlashInEra");
            await NominatorSlashInEraTypedStorage.InitializeAsync("Staking", "NominatorSlashInEra");
            await SlashingSpansTypedStorage.InitializeAsync("Staking", "SlashingSpans");
            await SpanSlashTypedStorage.InitializeAsync("Staking", "SpanSlash");
            await CurrentPlannedSessionTypedStorage.InitializeAsync("Staking", "CurrentPlannedSession");
            await DisabledValidatorsTypedStorage.InitializeAsync("Staking", "DisabledValidators");
            await ChillThresholdTypedStorage.InitializeAsync("Staking", "ChillThreshold");
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ValidatorCount
        /// </summary>
        [StorageChange("Staking", "ValidatorCount")]
        public void OnUpdateValidatorCount(string data)
        {
            ValidatorCountTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> ValidatorCount
        ///  The ideal number of active validators.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 GetValidatorCount()
        {
            return ValidatorCountTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.MinimumValidatorCount
        /// </summary>
        [StorageChange("Staking", "MinimumValidatorCount")]
        public void OnUpdateMinimumValidatorCount(string data)
        {
            MinimumValidatorCountTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MinimumValidatorCount
        ///  Minimum number of staking participants before emergency conditions are imposed.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 GetMinimumValidatorCount()
        {
            return MinimumValidatorCountTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.Invulnerables
        /// </summary>
        [StorageChange("Staking", "Invulnerables")]
        public void OnUpdateInvulnerables(string data)
        {
            InvulnerablesTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> Invulnerables
        ///  Any validators that may never be slashed or forcibly kicked. It's a Vec since they're
        ///  easy to initialize and the performance hit is minimal (we expect no more than four
        ///  invulnerables) and restricted to testnets.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> GetInvulnerables()
        {
            return InvulnerablesTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.Bonded
        /// </summary>
        [StorageChange("Staking", "Bonded")]
        public void OnUpdateBonded(string key, string data)
        {
            BondedTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> Bonded
        ///  Map from all locked "stash" accounts to the controller account.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 GetBonded(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (BondedTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.MinNominatorBond
        /// </summary>
        [StorageChange("Staking", "MinNominatorBond")]
        public void OnUpdateMinNominatorBond(string data)
        {
            MinNominatorBondTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MinNominatorBond
        ///  The minimum active bond to become and maintain the role of a nominator.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 GetMinNominatorBond()
        {
            return MinNominatorBondTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.MinValidatorBond
        /// </summary>
        [StorageChange("Staking", "MinValidatorBond")]
        public void OnUpdateMinValidatorBond(string data)
        {
            MinValidatorBondTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MinValidatorBond
        ///  The minimum active bond to become and maintain the role of a validator.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 GetMinValidatorBond()
        {
            return MinValidatorBondTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.MinimumActiveStake
        /// </summary>
        [StorageChange("Staking", "MinimumActiveStake")]
        public void OnUpdateMinimumActiveStake(string data)
        {
            MinimumActiveStakeTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MinimumActiveStake
        ///  The minimum active nominator stake of the last successful election.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 GetMinimumActiveStake()
        {
            return MinimumActiveStakeTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.MinCommission
        /// </summary>
        [StorageChange("Staking", "MinCommission")]
        public void OnUpdateMinCommission(string data)
        {
            MinCommissionTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MinCommission
        ///  The minimum amount of commission that validators can set.
        /// 
        ///  If set to `0`, no limit exists.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill GetMinCommission()
        {
            return MinCommissionTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.Ledger
        /// </summary>
        [StorageChange("Staking", "Ledger")]
        public void OnUpdateLedger(string key, string data)
        {
            LedgerTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> Ledger
        ///  Map from all (unlocked) "controller" accounts to the info regarding the staking.
        /// 
        ///  Note: All the reads and mutations to this storage *MUST* be done through the methods exposed
        ///  by [`StakingLedger`] to ensure data and lock consistency.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.StakingLedger GetLedger(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (LedgerTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.StakingLedger result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.Payee
        /// </summary>
        [StorageChange("Staking", "Payee")]
        public void OnUpdatePayee(string key, string data)
        {
            PayeeTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> Payee
        ///  Where the reward payment should be made. Keyed by stash.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumRewardDestination GetPayee(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (PayeeTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumRewardDestination result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.Validators
        /// </summary>
        [StorageChange("Staking", "Validators")]
        public void OnUpdateValidators(string key, string data)
        {
            ValidatorsTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> Validators
        ///  The map from (wannabe) validator stash key to the preferences of that validator.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs GetValidators(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ValidatorsTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.CounterForValidators
        /// </summary>
        [StorageChange("Staking", "CounterForValidators")]
        public void OnUpdateCounterForValidators(string data)
        {
            CounterForValidatorsTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CounterForValidators
        /// Counter for the related counted storage map
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 GetCounterForValidators()
        {
            return CounterForValidatorsTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.MaxValidatorsCount
        /// </summary>
        [StorageChange("Staking", "MaxValidatorsCount")]
        public void OnUpdateMaxValidatorsCount(string data)
        {
            MaxValidatorsCountTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MaxValidatorsCount
        ///  The maximum validator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 GetMaxValidatorsCount()
        {
            return MaxValidatorsCountTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.Nominators
        /// </summary>
        [StorageChange("Staking", "Nominators")]
        public void OnUpdateNominators(string key, string data)
        {
            NominatorsTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> Nominators
        ///  The map from nominator stash key to their nomination preferences, namely the validators that
        ///  they wish to support.
        /// 
        ///  Note that the keys of this storage map might become non-decodable in case the
        ///  account's [`NominationsQuota::MaxNominations`] configuration is decreased.
        ///  In this rare case, these nominators
        ///  are still existent in storage, their key is correct and retrievable (i.e. `contains_key`
        ///  indicates that they exist), but their value cannot be decoded. Therefore, the non-decodable
        ///  nominators will effectively not-exist, until they re-submit their preferences such that it
        ///  is within the bounds of the newly set `Config::MaxNominations`.
        /// 
        ///  This implies that `::iter_keys().count()` and `::iter().count()` might return different
        ///  values for this map. Moreover, the main `::count()` is aligned with the former, namely the
        ///  number of keys that exist.
        /// 
        ///  Lastly, if any of the nominators become non-decodable, they can be chilled immediately via
        ///  [`Call::chill_other`] dispatchable by anyone.
        /// 
        ///  TWOX-NOTE: SAFE since `AccountId` is a secure hash.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.Nominations GetNominators(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (NominatorsTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.Nominations result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.CounterForNominators
        /// </summary>
        [StorageChange("Staking", "CounterForNominators")]
        public void OnUpdateCounterForNominators(string data)
        {
            CounterForNominatorsTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CounterForNominators
        /// Counter for the related counted storage map
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 GetCounterForNominators()
        {
            return CounterForNominatorsTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.VirtualStakers
        /// </summary>
        [StorageChange("Staking", "VirtualStakers")]
        public void OnUpdateVirtualStakers(string key, string data)
        {
            VirtualStakersTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> VirtualStakers
        ///  Stakers whose funds are managed by other pallets.
        /// 
        ///  This pallet does not apply any locks on them, therefore they are only virtually bonded. They
        ///  are expected to be keyless accounts and hence should not be allowed to mutate their ledger
        ///  directly via this pallet. Instead, these accounts are managed by other pallets and accessed
        ///  via low level apis. We keep track of them to do minimal integrity checks.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseTuple GetVirtualStakers(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (VirtualStakersTypedStorage.Dictionary.TryGetValue(key, out Substrate.NetApi.Model.Types.Base.BaseTuple result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.CounterForVirtualStakers
        /// </summary>
        [StorageChange("Staking", "CounterForVirtualStakers")]
        public void OnUpdateCounterForVirtualStakers(string data)
        {
            CounterForVirtualStakersTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CounterForVirtualStakers
        /// Counter for the related counted storage map
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 GetCounterForVirtualStakers()
        {
            return CounterForVirtualStakersTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.MaxNominatorsCount
        /// </summary>
        [StorageChange("Staking", "MaxNominatorsCount")]
        public void OnUpdateMaxNominatorsCount(string data)
        {
            MaxNominatorsCountTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MaxNominatorsCount
        ///  The maximum nominator count before we stop allowing new validators to join.
        /// 
        ///  When this value is not set, no limits are enforced.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 GetMaxNominatorsCount()
        {
            return MaxNominatorsCountTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.CurrentEra
        /// </summary>
        [StorageChange("Staking", "CurrentEra")]
        public void OnUpdateCurrentEra(string data)
        {
            CurrentEraTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CurrentEra
        ///  The current era index.
        /// 
        ///  This is the latest planned era, depending on how the Session pallet queues the validator
        ///  set, it might be active or not.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 GetCurrentEra()
        {
            return CurrentEraTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ActiveEra
        /// </summary>
        [StorageChange("Staking", "ActiveEra")]
        public void OnUpdateActiveEra(string data)
        {
            ActiveEraTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> ActiveEra
        ///  The active era information, it holds index and start.
        /// 
        ///  The active era is the era being currently rewarded. Validator set of this era must be
        ///  equal to [`SessionInterface::validators`].
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ActiveEraInfo GetActiveEra()
        {
            return ActiveEraTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ErasStartSessionIndex
        /// </summary>
        [StorageChange("Staking", "ErasStartSessionIndex")]
        public void OnUpdateErasStartSessionIndex(string key, string data)
        {
            ErasStartSessionIndexTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasStartSessionIndex
        ///  The session index at which the era start for the last [`Config::HistoryDepth`] eras.
        /// 
        ///  Note: This tracks the starting session (i.e. session index when era start being active)
        ///  for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 GetErasStartSessionIndex(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasStartSessionIndexTypedStorage.Dictionary.TryGetValue(key, out Substrate.NetApi.Model.Types.Primitive.U32 result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ErasStakers
        /// </summary>
        [StorageChange("Staking", "ErasStakers")]
        public void OnUpdateErasStakers(string key, string data)
        {
            ErasStakersTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasStakers
        ///  Exposure of validator at era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// 
        ///  Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure GetErasStakers(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasStakersTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ErasStakersOverview
        /// </summary>
        [StorageChange("Staking", "ErasStakersOverview")]
        public void OnUpdateErasStakersOverview(string key, string data)
        {
            ErasStakersOverviewTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasStakersOverview
        ///  Summary of validator exposure at a given era.
        /// 
        ///  This contains the total stake in support of the validator and their own stake. In addition,
        ///  it can also be used to get the number of nominators backing this validator and the number of
        ///  exposure pages they are divided into. The page count is useful to determine the number of
        ///  pages of rewards that needs to be claimed.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        ///  Should only be accessed through `EraInfo`.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty overview is returned.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.PagedExposureMetadata GetErasStakersOverview(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasStakersOverviewTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.PagedExposureMetadata result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ErasStakersClipped
        /// </summary>
        [StorageChange("Staking", "ErasStakersClipped")]
        public void OnUpdateErasStakersClipped(string key, string data)
        {
            ErasStakersClippedTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasStakersClipped
        ///  Clipped Exposure of validator at era.
        /// 
        ///  Note: This is deprecated, should be used as read-only and will be removed in the future.
        ///  New `Exposure`s are stored in a paged manner in `ErasStakersPaged` instead.
        /// 
        ///  This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the
        ///  `T::MaxExposurePageSize` biggest stakers.
        ///  (Note: the field `total` and `own` of the exposure remains unchanged).
        ///  This is used to limit the i/o cost for the nominator payout.
        /// 
        ///  This is keyed fist by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  It is removed after [`Config::HistoryDepth`] eras.
        ///  If stakers hasn't been set or has been removed then empty exposure is returned.
        /// 
        ///  Note: Deprecated since v14. Use `EraInfo` instead to work with exposures.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure GetErasStakersClipped(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasStakersClippedTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.Exposure result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ErasStakersPaged
        /// </summary>
        [StorageChange("Staking", "ErasStakersPaged")]
        public void OnUpdateErasStakersPaged(string key, string data)
        {
            ErasStakersPagedTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasStakersPaged
        ///  Paginated exposure of a validator at given era.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion, then stash account and finally
        ///  the page. Should only be accessed through `EraInfo`.
        /// 
        ///  This is cleared after [`Config::HistoryDepth`] eras.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.ExposurePage GetErasStakersPaged(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasStakersPagedTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_staking.ExposurePage result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ClaimedRewards
        /// </summary>
        [StorageChange("Staking", "ClaimedRewards")]
        public void OnUpdateClaimedRewards(string key, string data)
        {
            ClaimedRewardsTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ClaimedRewards
        ///  History of claimed paged rewards by era and validator.
        /// 
        ///  This is keyed by era and validator stash which maps to the set of page indexes which have
        ///  been claimed.
        /// 
        ///  It is removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32> GetClaimedRewards(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ClaimedRewardsTypedStorage.Dictionary.TryGetValue(key, out Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32> result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ErasValidatorPrefs
        /// </summary>
        [StorageChange("Staking", "ErasValidatorPrefs")]
        public void OnUpdateErasValidatorPrefs(string key, string data)
        {
            ErasValidatorPrefsTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasValidatorPrefs
        ///  Similar to `ErasStakers`, this holds the preferences of validators.
        /// 
        ///  This is keyed first by the era index to allow bulk deletion and then the stash account.
        /// 
        ///  Is it removed after [`Config::HistoryDepth`] eras.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs GetErasValidatorPrefs(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasValidatorPrefsTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.ValidatorPrefs result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ErasValidatorReward
        /// </summary>
        [StorageChange("Staking", "ErasValidatorReward")]
        public void OnUpdateErasValidatorReward(string key, string data)
        {
            ErasValidatorRewardTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasValidatorReward
        ///  The total validator era payout for the last [`Config::HistoryDepth`] eras.
        /// 
        ///  Eras that haven't finished yet or has been removed doesn't have reward.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 GetErasValidatorReward(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasValidatorRewardTypedStorage.Dictionary.TryGetValue(key, out Substrate.NetApi.Model.Types.Primitive.U128 result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ErasRewardPoints
        /// </summary>
        [StorageChange("Staking", "ErasRewardPoints")]
        public void OnUpdateErasRewardPoints(string key, string data)
        {
            ErasRewardPointsTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasRewardPoints
        ///  Rewards for the last [`Config::HistoryDepth`] eras.
        ///  If reward hasn't been set or has been removed then 0 reward is returned.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EraRewardPoints GetErasRewardPoints(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasRewardPointsTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EraRewardPoints result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ErasTotalStake
        /// </summary>
        [StorageChange("Staking", "ErasTotalStake")]
        public void OnUpdateErasTotalStake(string key, string data)
        {
            ErasTotalStakeTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ErasTotalStake
        ///  The total amount staked for the last [`Config::HistoryDepth`] eras.
        ///  If total hasn't been set or has been removed then 0 stake is returned.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 GetErasTotalStake(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ErasTotalStakeTypedStorage.Dictionary.TryGetValue(key, out Substrate.NetApi.Model.Types.Primitive.U128 result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ForceEra
        /// </summary>
        [StorageChange("Staking", "ForceEra")]
        public void OnUpdateForceEra(string data)
        {
            ForceEraTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> ForceEra
        ///  Mode of era forcing.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.EnumForcing GetForceEra()
        {
            return ForceEraTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.MaxStakedRewards
        /// </summary>
        [StorageChange("Staking", "MaxStakedRewards")]
        public void OnUpdateMaxStakedRewards(string data)
        {
            MaxStakedRewardsTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> MaxStakedRewards
        ///  Maximum staked rewards, i.e. the percentage of the era inflation that
        ///  is used for stake rewards.
        ///  See [Era payout](./index.html#era-payout).
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent GetMaxStakedRewards()
        {
            return MaxStakedRewardsTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.SlashRewardFraction
        /// </summary>
        [StorageChange("Staking", "SlashRewardFraction")]
        public void OnUpdateSlashRewardFraction(string data)
        {
            SlashRewardFractionTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> SlashRewardFraction
        ///  The percentage of the slash that is distributed to reporters.
        /// 
        ///  The rest of the slashed value is handled by the `Slash`.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill GetSlashRewardFraction()
        {
            return SlashRewardFractionTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.CanceledSlashPayout
        /// </summary>
        [StorageChange("Staking", "CanceledSlashPayout")]
        public void OnUpdateCanceledSlashPayout(string data)
        {
            CanceledSlashPayoutTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CanceledSlashPayout
        ///  The amount of currency given to reporters of a slash event which was
        ///  canceled by extraordinary circumstances (e.g. governance).
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 GetCanceledSlashPayout()
        {
            return CanceledSlashPayoutTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.UnappliedSlashes
        /// </summary>
        [StorageChange("Staking", "UnappliedSlashes")]
        public void OnUpdateUnappliedSlashes(string key, string data)
        {
            UnappliedSlashesTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> UnappliedSlashes
        ///  All unapplied slashes that are queued for later.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.UnappliedSlash> GetUnappliedSlashes(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (UnappliedSlashesTypedStorage.Dictionary.TryGetValue(key, out Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.UnappliedSlash> result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.BondedEras
        /// </summary>
        [StorageChange("Staking", "BondedEras")]
        public void OnUpdateBondedEras(string data)
        {
            BondedErasTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> BondedEras
        ///  A mapping from still-bonded eras to the first session index of that era.
        /// 
        ///  Must contains information for eras for the range:
        ///  `[active_era - bounding_duration; active_era]`
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>> GetBondedEras()
        {
            return BondedErasTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ValidatorSlashInEra
        /// </summary>
        [StorageChange("Staking", "ValidatorSlashInEra")]
        public void OnUpdateValidatorSlashInEra(string key, string data)
        {
            ValidatorSlashInEraTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> ValidatorSlashInEra
        ///  All slashing events on validators, mapped by era to the highest slash proportion
        ///  and slash value of the era.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128> GetValidatorSlashInEra(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (ValidatorSlashInEraTypedStorage.Dictionary.TryGetValue(key, out Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Perbill, Substrate.NetApi.Model.Types.Primitive.U128> result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.NominatorSlashInEra
        /// </summary>
        [StorageChange("Staking", "NominatorSlashInEra")]
        public void OnUpdateNominatorSlashInEra(string key, string data)
        {
            NominatorSlashInEraTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> NominatorSlashInEra
        ///  All slashing events on nominators, mapped by era to the highest slash value of the era.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U128 GetNominatorSlashInEra(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (NominatorSlashInEraTypedStorage.Dictionary.TryGetValue(key, out Substrate.NetApi.Model.Types.Primitive.U128 result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.SlashingSpans
        /// </summary>
        [StorageChange("Staking", "SlashingSpans")]
        public void OnUpdateSlashingSpans(string key, string data)
        {
            SlashingSpansTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> SlashingSpans
        ///  Slashing spans for stash accounts.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SlashingSpans GetSlashingSpans(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (SlashingSpansTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SlashingSpans result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.SpanSlash
        /// </summary>
        [StorageChange("Staking", "SpanSlash")]
        public void OnUpdateSpanSlash(string key, string data)
        {
            SpanSlashTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> SpanSlash
        ///  Records information about the maximum slash of a stash within a slashing span,
        ///  as well as how much reward has been paid out.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SpanRecord GetSpanSlash(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (SpanSlashTypedStorage.Dictionary.TryGetValue(key, out Substrate.Kusama.NET.NetApiExt.Generated.Model.pallet_staking.slashing.SpanRecord result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Staking.CurrentPlannedSession
        /// </summary>
        [StorageChange("Staking", "CurrentPlannedSession")]
        public void OnUpdateCurrentPlannedSession(string data)
        {
            CurrentPlannedSessionTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> CurrentPlannedSession
        ///  The last planned session scheduled by the session pallet.
        /// 
        ///  This is basically in sync with the call to [`pallet_session::SessionManager::new_session`].
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 GetCurrentPlannedSession()
        {
            return CurrentPlannedSessionTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.DisabledValidators
        /// </summary>
        [StorageChange("Staking", "DisabledValidators")]
        public void OnUpdateDisabledValidators(string data)
        {
            DisabledValidatorsTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> DisabledValidators
        ///  Indices of validators that have offended in the active era. The offenders are disabled for a
        ///  whole era. For this reason they are kept here - only staking pallet knows about eras. The
        ///  implementor of [`DisablingStrategy`] defines if a validator should be disabled which
        ///  implicitly means that the implementor also controls the max number of disabled validators.
        /// 
        ///  The vec is always kept sorted so that we can find whether a given validator has previously
        ///  offended using binary search.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U32> GetDisabledValidators()
        {
            return DisabledValidatorsTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Staking.ChillThreshold
        /// </summary>
        [StorageChange("Staking", "ChillThreshold")]
        public void OnUpdateChillThreshold(string data)
        {
            ChillThresholdTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> ChillThreshold
        ///  The threshold for when users can start calling `chill_other` for other validators /
        ///  nominators. The threshold is compared to the actual number of validators / nominators
        ///  (`CountFor*`) in the system compared to the configured max (`Max*Count`).
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.sp_arithmetic.per_things.Percent GetChillThreshold()
        {
            return ChillThresholdTypedStorage.Get();
        }
    }
}
