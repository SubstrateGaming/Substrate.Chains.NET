//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using Substrate.ServiceLayer.Attributes;
using Substrate.ServiceLayer.Storage;
using System.Collections.Generic;
using System.Threading.Tasks;


namespace Substrate.Kusama.NET.RestService.Generated.Storage
{
    
    
    /// <summary>
    /// IUmpStorage interface definition.
    /// </summary>
    public interface IUmpStorage : IStorage
    {
        
        /// <summary>
        /// >> RelayDispatchQueues
        ///  The messages waiting to be handled by the relay-chain originating from a certain parachain.
        /// 
        ///  Note that some upward messages might have been already processed by the inclusion logic. E.g.
        ///  channel management messages.
        /// 
        ///  The messages are processed in FIFO order.
        /// </summary>
        Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>> GetRelayDispatchQueues(string key);
        
        /// <summary>
        /// >> RelayDispatchQueueSize
        ///  Size of the dispatch queues. Caches sizes of the queues in `RelayDispatchQueue`.
        /// 
        ///  First item in the tuple is the count of messages and second
        ///  is the total length (in bytes) of the message payloads.
        /// 
        ///  Note that this is an auxiliary mapping: it's possible to tell the byte size and the number of
        ///  messages only looking at `RelayDispatchQueues`. This mapping is separate to avoid the cost of
        ///  loading the whole message queue if only the total size and count are required.
        /// 
        ///  Invariant:
        ///  - The set of keys should exactly match the set of keys of `RelayDispatchQueues`.
        /// </summary>
        Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> GetRelayDispatchQueueSize(string key);
        
        /// <summary>
        /// >> NeedsDispatch
        ///  The ordered list of `ParaId`s that have a `RelayDispatchQueue` entry.
        /// 
        ///  Invariant:
        ///  - The set of items from this vector should be exactly the set of the keys in
        ///    `RelayDispatchQueues` and `RelayDispatchQueueSize`.
        /// </summary>
        Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id> GetNeedsDispatch();
        
        /// <summary>
        /// >> NextDispatchRoundStartWith
        ///  This is the para that gets will get dispatched first during the next upward dispatchable queue
        ///  execution round.
        /// 
        ///  Invariant:
        ///  - If `Some(para)`, then `para` must be present in `NeedsDispatch`.
        /// </summary>
        Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id GetNextDispatchRoundStartWith();
        
        /// <summary>
        /// >> Overweight
        ///  The messages that exceeded max individual message weight budget.
        /// 
        ///  These messages stay there until manually dispatched.
        /// </summary>
        Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>> GetOverweight(string key);
        
        /// <summary>
        /// >> OverweightCount
        ///  The number of overweight messages ever recorded in `Overweight` (and thus the lowest free
        ///  index).
        /// </summary>
        Substrate.NetApi.Model.Types.Primitive.U64 GetOverweightCount();
    }
    
    /// <summary>
    /// UmpStorage class definition.
    /// </summary>
    public sealed class UmpStorage : IUmpStorage
    {
        
        /// <summary>
        /// _relayDispatchQueuesTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>> _relayDispatchQueuesTypedStorage;
        
        /// <summary>
        /// _relayDispatchQueueSizeTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>> _relayDispatchQueueSizeTypedStorage;
        
        /// <summary>
        /// _needsDispatchTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id>> _needsDispatchTypedStorage;
        
        /// <summary>
        /// _nextDispatchRoundStartWithTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id> _nextDispatchRoundStartWithTypedStorage;
        
        /// <summary>
        /// _overweightTypedStorage typed storage field
        /// </summary>
        private TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>> _overweightTypedStorage;
        
        /// <summary>
        /// _overweightCountTypedStorage typed storage field
        /// </summary>
        private TypedStorage<Substrate.NetApi.Model.Types.Primitive.U64> _overweightCountTypedStorage;
        
        /// <summary>
        /// UmpStorage constructor.
        /// </summary>
        public UmpStorage(IStorageDataProvider storageDataProvider, List<IStorageChangeDelegate> storageChangeDelegates)
        {
            this.RelayDispatchQueuesTypedStorage = new TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>>("Ump.RelayDispatchQueues", storageDataProvider, storageChangeDelegates);
            this.RelayDispatchQueueSizeTypedStorage = new TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>("Ump.RelayDispatchQueueSize", storageDataProvider, storageChangeDelegates);
            this.NeedsDispatchTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id>>("Ump.NeedsDispatch", storageDataProvider, storageChangeDelegates);
            this.NextDispatchRoundStartWithTypedStorage = new TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id>("Ump.NextDispatchRoundStartWith", storageDataProvider, storageChangeDelegates);
            this.OverweightTypedStorage = new TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>>("Ump.Overweight", storageDataProvider, storageChangeDelegates);
            this.OverweightCountTypedStorage = new TypedStorage<Substrate.NetApi.Model.Types.Primitive.U64>("Ump.OverweightCount", storageDataProvider, storageChangeDelegates);
        }
        
        /// <summary>
        /// _relayDispatchQueuesTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>> RelayDispatchQueuesTypedStorage
        {
            get
            {
                return _relayDispatchQueuesTypedStorage;
            }
            set
            {
                _relayDispatchQueuesTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _relayDispatchQueueSizeTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>> RelayDispatchQueueSizeTypedStorage
        {
            get
            {
                return _relayDispatchQueueSizeTypedStorage;
            }
            set
            {
                _relayDispatchQueueSizeTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _needsDispatchTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id>> NeedsDispatchTypedStorage
        {
            get
            {
                return _needsDispatchTypedStorage;
            }
            set
            {
                _needsDispatchTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _nextDispatchRoundStartWithTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id> NextDispatchRoundStartWithTypedStorage
        {
            get
            {
                return _nextDispatchRoundStartWithTypedStorage;
            }
            set
            {
                _nextDispatchRoundStartWithTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _overweightTypedStorage property
        /// </summary>
        public TypedMapStorage<Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>>> OverweightTypedStorage
        {
            get
            {
                return _overweightTypedStorage;
            }
            set
            {
                _overweightTypedStorage = value;
            }
        }
        
        /// <summary>
        /// _overweightCountTypedStorage property
        /// </summary>
        public TypedStorage<Substrate.NetApi.Model.Types.Primitive.U64> OverweightCountTypedStorage
        {
            get
            {
                return _overweightCountTypedStorage;
            }
            set
            {
                _overweightCountTypedStorage = value;
            }
        }
        
        /// <summary>
        /// Connects to all storages and initializes the change subscription handling.
        /// </summary>
        public async Task InitializeAsync(Substrate.ServiceLayer.Storage.IStorageDataProvider dataProvider)
        {
            await RelayDispatchQueuesTypedStorage.InitializeAsync("Ump", "RelayDispatchQueues");
            await RelayDispatchQueueSizeTypedStorage.InitializeAsync("Ump", "RelayDispatchQueueSize");
            await NeedsDispatchTypedStorage.InitializeAsync("Ump", "NeedsDispatch");
            await NextDispatchRoundStartWithTypedStorage.InitializeAsync("Ump", "NextDispatchRoundStartWith");
            await OverweightTypedStorage.InitializeAsync("Ump", "Overweight");
            await OverweightCountTypedStorage.InitializeAsync("Ump", "OverweightCount");
        }
        
        /// <summary>
        /// Implements any storage change for Ump.RelayDispatchQueues
        /// </summary>
        [StorageChange("Ump", "RelayDispatchQueues")]
        public void OnUpdateRelayDispatchQueues(string key, string data)
        {
            RelayDispatchQueuesTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> RelayDispatchQueues
        ///  The messages waiting to be handled by the relay-chain originating from a certain parachain.
        /// 
        ///  Note that some upward messages might have been already processed by the inclusion logic. E.g.
        ///  channel management messages.
        /// 
        ///  The messages are processed in FIFO order.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>> GetRelayDispatchQueues(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (RelayDispatchQueuesTypedStorage.Dictionary.TryGetValue(key, out Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>> result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Ump.RelayDispatchQueueSize
        /// </summary>
        [StorageChange("Ump", "RelayDispatchQueueSize")]
        public void OnUpdateRelayDispatchQueueSize(string key, string data)
        {
            RelayDispatchQueueSizeTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> RelayDispatchQueueSize
        ///  Size of the dispatch queues. Caches sizes of the queues in `RelayDispatchQueue`.
        /// 
        ///  First item in the tuple is the count of messages and second
        ///  is the total length (in bytes) of the message payloads.
        /// 
        ///  Note that this is an auxiliary mapping: it's possible to tell the byte size and the number of
        ///  messages only looking at `RelayDispatchQueues`. This mapping is separate to avoid the cost of
        ///  loading the whole message queue if only the total size and count are required.
        /// 
        ///  Invariant:
        ///  - The set of keys should exactly match the set of keys of `RelayDispatchQueues`.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> GetRelayDispatchQueueSize(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (RelayDispatchQueueSizeTypedStorage.Dictionary.TryGetValue(key, out Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32> result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Ump.NeedsDispatch
        /// </summary>
        [StorageChange("Ump", "NeedsDispatch")]
        public void OnUpdateNeedsDispatch(string data)
        {
            NeedsDispatchTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> NeedsDispatch
        ///  The ordered list of `ParaId`s that have a `RelayDispatchQueue` entry.
        /// 
        ///  Invariant:
        ///  - The set of items from this vector should be exactly the set of the keys in
        ///    `RelayDispatchQueues` and `RelayDispatchQueueSize`.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id> GetNeedsDispatch()
        {
            return NeedsDispatchTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Ump.NextDispatchRoundStartWith
        /// </summary>
        [StorageChange("Ump", "NextDispatchRoundStartWith")]
        public void OnUpdateNextDispatchRoundStartWith(string data)
        {
            NextDispatchRoundStartWithTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> NextDispatchRoundStartWith
        ///  This is the para that gets will get dispatched first during the next upward dispatchable queue
        ///  execution round.
        /// 
        ///  Invariant:
        ///  - If `Some(para)`, then `para` must be present in `NeedsDispatch`.
        /// </summary>
        public Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id GetNextDispatchRoundStartWith()
        {
            return NextDispatchRoundStartWithTypedStorage.Get();
        }
        
        /// <summary>
        /// Implements any storage change for Ump.Overweight
        /// </summary>
        [StorageChange("Ump", "Overweight")]
        public void OnUpdateOverweight(string key, string data)
        {
            OverweightTypedStorage.Update(key, data);
        }
        
        /// <summary>
        /// >> Overweight
        ///  The messages that exceeded max individual message weight budget.
        /// 
        ///  These messages stay there until manually dispatched.
        /// </summary>
        public Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>> GetOverweight(string key)
        {
            if ((key == null))
            {
                return null;
            }
            if (OverweightTypedStorage.Dictionary.TryGetValue(key, out Substrate.NetApi.Model.Types.Base.BaseTuple<Substrate.Kusama.NET.NetApiExt.Generated.Model.polkadot_parachain.primitives.Id, Substrate.NetApi.Model.Types.Base.BaseVec<Substrate.NetApi.Model.Types.Primitive.U8>> result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }
        
        /// <summary>
        /// Implements any storage change for Ump.OverweightCount
        /// </summary>
        [StorageChange("Ump", "OverweightCount")]
        public void OnUpdateOverweightCount(string data)
        {
            OverweightCountTypedStorage.Update(data);
        }
        
        /// <summary>
        /// >> OverweightCount
        ///  The number of overweight messages ever recorded in `Overweight` (and thus the lowest free
        ///  index).
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U64 GetOverweightCount()
        {
            return OverweightCountTypedStorage.Get();
        }
    }
}
