//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;


namespace Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.pallet
{
    
    
    /// <summary>
    /// >> Call
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public enum Call
    {
        
        /// <summary>
        /// >> configure
        /// Configure the pallet.
        /// 
        /// - `origin`: Must be Root or pass `AdminOrigin`.
        /// - `config`: The configuration for this pallet.
        /// </summary>
        configure = 0,
        
        /// <summary>
        /// >> reserve
        /// Reserve a core for a workload.
        /// 
        /// - `origin`: Must be Root or pass `AdminOrigin`.
        /// - `workload`: The workload which should be permanently placed on a core.
        /// </summary>
        reserve = 1,
        
        /// <summary>
        /// >> unreserve
        /// Cancel a reservation for a workload.
        /// 
        /// - `origin`: Must be Root or pass `AdminOrigin`.
        /// - `item_index`: The index of the reservation. Usually this will also be the index of the
        ///   core on which the reservation has been scheduled. However, it is possible that if
        ///   other cores are reserved or unreserved in the same sale rotation that they won't
        ///   correspond, so it's better to look up the core properly in the `Reservations` storage.
        /// </summary>
        unreserve = 2,
        
        /// <summary>
        /// >> set_lease
        /// Reserve a core for a single task workload for a limited period.
        /// 
        /// In the interlude and sale period where Bulk Coretime is sold for the period immediately
        /// after `until`, then the same workload may be renewed.
        /// 
        /// - `origin`: Must be Root or pass `AdminOrigin`.
        /// - `task`: The workload which should be placed on a core.
        /// - `until`: The timeslice now earlier than which `task` should be placed as a workload on
        ///   a core.
        /// </summary>
        set_lease = 3,
        
        /// <summary>
        /// >> start_sales
        /// Begin the Bulk Coretime sales rotation.
        /// 
        /// - `origin`: Must be Root or pass `AdminOrigin`.
        /// - `end_price`: The price after the leadin period of Bulk Coretime in the first sale.
        /// - `extra_cores`: Number of extra cores that should be requested on top of the cores
        ///   required for `Reservations` and `Leases`.
        /// 
        /// This will call [`Self::request_core_count`] internally to set the correct core count on
        /// the relay chain.
        /// </summary>
        start_sales = 4,
        
        /// <summary>
        /// >> purchase
        /// Purchase Bulk Coretime in the ongoing Sale.
        /// 
        /// - `origin`: Must be a Signed origin with at least enough funds to pay the current price
        ///   of Bulk Coretime.
        /// - `price_limit`: An amount no more than which should be paid.
        /// </summary>
        purchase = 5,
        
        /// <summary>
        /// >> renew
        /// Renew Bulk Coretime in the ongoing Sale or its prior Interlude Period.
        /// 
        /// - `origin`: Must be a Signed origin with at least enough funds to pay the renewal price
        ///   of the core.
        /// - `core`: The core which should be renewed.
        /// </summary>
        renew = 6,
        
        /// <summary>
        /// >> transfer
        /// Transfer a Bulk Coretime Region to a new owner.
        /// 
        /// - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
        /// - `region_id`: The Region whose ownership should change.
        /// - `new_owner`: The new owner for the Region.
        /// </summary>
        transfer = 7,
        
        /// <summary>
        /// >> partition
        /// Split a Bulk Coretime Region into two non-overlapping Regions at a particular time into
        /// the region.
        /// 
        /// - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
        /// - `region_id`: The Region which should be partitioned into two non-overlapping Regions.
        /// - `pivot`: The offset in time into the Region at which to make the split.
        /// </summary>
        partition = 8,
        
        /// <summary>
        /// >> interlace
        /// Split a Bulk Coretime Region into two wholly-overlapping Regions with complementary
        /// interlace masks which together make up the original Region's interlace mask.
        /// 
        /// - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
        /// - `region_id`: The Region which should become two interlaced Regions of incomplete
        ///   regularity.
        /// - `pivot`: The interlace mask of one of the two new regions (the other is its partial
        ///   complement).
        /// </summary>
        interlace = 9,
        
        /// <summary>
        /// >> assign
        /// Assign a Bulk Coretime Region to a task.
        /// 
        /// - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
        /// - `region_id`: The Region which should be assigned to the task.
        /// - `task`: The task to assign.
        /// - `finality`: Indication of whether this assignment is final (in which case it may be
        ///   eligible for renewal) or provisional (in which case it may be manipulated and/or
        /// reassigned at a later stage).
        /// </summary>
        assign = 10,
        
        /// <summary>
        /// >> pool
        /// Place a Bulk Coretime Region into the Instantaneous Coretime Pool.
        /// 
        /// - `origin`: Must be a Signed origin of the account which owns the Region `region_id`.
        /// - `region_id`: The Region which should be assigned to the Pool.
        /// - `payee`: The account which is able to collect any revenue due for the usage of this
        ///   Coretime.
        /// </summary>
        pool = 11,
        
        /// <summary>
        /// >> claim_revenue
        /// Claim the revenue owed from inclusion in the Instantaneous Coretime Pool.
        /// 
        /// - `origin`: Must be a Signed origin.
        /// - `region_id`: The Region which was assigned to the Pool.
        /// - `max_timeslices`: The maximum number of timeslices which should be processed. This
        ///   must be greater than 0. This may affect the weight of the call but should be ideally
        ///   made equivalent to the length of the Region `region_id`. If less, further dispatches
        ///   will be required with the same `region_id` to claim revenue for the remainder.
        /// </summary>
        claim_revenue = 12,
        
        /// <summary>
        /// >> purchase_credit
        /// Purchase credit for use in the Instantaneous Coretime Pool.
        /// 
        /// - `origin`: Must be a Signed origin able to pay at least `amount`.
        /// - `amount`: The amount of credit to purchase.
        /// - `beneficiary`: The account on the Relay-chain which controls the credit (generally
        ///   this will be the collator's hot wallet).
        /// </summary>
        purchase_credit = 13,
        
        /// <summary>
        /// >> drop_region
        /// Drop an expired Region from the chain.
        /// 
        /// - `origin`: Can be any kind of origin.
        /// - `region_id`: The Region which has expired.
        /// </summary>
        drop_region = 14,
        
        /// <summary>
        /// >> drop_contribution
        /// Drop an expired Instantaneous Pool Contribution record from the chain.
        /// 
        /// - `origin`: Can be any kind of origin.
        /// - `region_id`: The Region identifying the Pool Contribution which has expired.
        /// </summary>
        drop_contribution = 15,
        
        /// <summary>
        /// >> drop_history
        /// Drop an expired Instantaneous Pool History record from the chain.
        /// 
        /// - `origin`: Can be any kind of origin.
        /// - `region_id`: The time of the Pool History record which has expired.
        /// </summary>
        drop_history = 16,
        
        /// <summary>
        /// >> drop_renewal
        /// Drop an expired Allowed Renewal record from the chain.
        /// 
        /// - `origin`: Can be any kind of origin.
        /// - `core`: The core to which the expired renewal refers.
        /// - `when`: The timeslice to which the expired renewal refers. This must have passed.
        /// </summary>
        drop_renewal = 17,
        
        /// <summary>
        /// >> request_core_count
        /// Request a change to the number of cores available for scheduling work.
        /// 
        /// - `origin`: Must be Root or pass `AdminOrigin`.
        /// - `core_count`: The desired number of cores to be made available.
        /// </summary>
        request_core_count = 18,
        
        /// <summary>
        /// >> notify_core_count
        /// </summary>
        notify_core_count = 19,
        
        /// <summary>
        /// >> notify_revenue
        /// </summary>
        notify_revenue = 20,
        
        /// <summary>
        /// >> swap_leases
        /// </summary>
        swap_leases = 99,
    }
    
    /// <summary>
    /// >> 336 - Variant[pallet_broker.pallet.Call]
    /// Contains a variant per dispatchable extrinsic that this pallet has.
    /// </summary>
    public sealed class EnumCall : BaseEnumRust<Call>
    {
        
        /// <summary>
        /// Initializes a new instance of the class.
        /// </summary>
        public EnumCall()
        {
				AddTypeDecoder<Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.ConfigRecord>(Call.configure);
				AddTypeDecoder<Substrate.Coretime.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT4>(Call.reserve);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U32>(Call.unreserve);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.set_lease);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.NetApi.Model.Types.Primitive.U16>>(Call.start_sales);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U128>(Call.purchase);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U16>(Call.renew);
				AddTypeDecoder<BaseTuple<Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.RegionId, Substrate.Coretime.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>>(Call.transfer);
				AddTypeDecoder<BaseTuple<Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.RegionId, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.partition);
				AddTypeDecoder<BaseTuple<Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.RegionId, Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.core_mask.CoreMask>>(Call.interlace);
				AddTypeDecoder<BaseTuple<Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.RegionId, Substrate.NetApi.Model.Types.Primitive.U32, Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.EnumFinality>>(Call.assign);
				AddTypeDecoder<BaseTuple<Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.RegionId, Substrate.Coretime.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32, Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.EnumFinality>>(Call.pool);
				AddTypeDecoder<BaseTuple<Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.RegionId, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.claim_revenue);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U128, Substrate.Coretime.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>>(Call.purchase_credit);
				AddTypeDecoder<Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.RegionId>(Call.drop_region);
				AddTypeDecoder<Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.RegionId>(Call.drop_contribution);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U32>(Call.drop_history);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U16, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.drop_renewal);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U16>(Call.request_core_count);
				AddTypeDecoder<Substrate.NetApi.Model.Types.Primitive.U16>(Call.notify_core_count);
				AddTypeDecoder<Substrate.Coretime.NET.NetApiExt.Generated.Model.pallet_broker.types.OnDemandRevenueRecord>(Call.notify_revenue);
				AddTypeDecoder<BaseTuple<Substrate.NetApi.Model.Types.Primitive.U32, Substrate.NetApi.Model.Types.Primitive.U32>>(Call.swap_leases);
        }
    }
}
