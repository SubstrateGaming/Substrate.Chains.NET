//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Substrate.NetApi;
using Substrate.NetApi.Model.Extrinsics;
using Substrate.NetApi.Model.Meta;
using Substrate.NetApi.Model.Types;
using Substrate.NetApi.Model.Types.Base;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;


namespace Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Storage
{
    
    
    /// <summary>
    /// >> BridgeKusamaMessagesStorage
    /// </summary>
    public sealed class BridgeKusamaMessagesStorage
    {
        
        // Substrate client for the storage calls.
        private SubstrateClientExt _client;
        
        /// <summary>
        /// >> BridgeKusamaMessagesStorage Constructor
        /// </summary>
        public BridgeKusamaMessagesStorage(SubstrateClientExt client)
        {
            this._client = client;
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("BridgeKusamaMessages", "PalletOwner"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("BridgeKusamaMessages", "PalletOperatingMode"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(null, null, typeof(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.EnumMessagesOperatingMode)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("BridgeKusamaMessages", "InboundLanes"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.LaneId), typeof(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.InboundLaneData)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("BridgeKusamaMessages", "OutboundLanes"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.LaneId), typeof(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.OutboundLaneData)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("BridgeKusamaMessages", "OutboundLanesCongestedSignals"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.LaneId), typeof(Substrate.NetApi.Model.Types.Primitive.Bool)));
            _client.StorageKeyDict.Add(new System.Tuple<string, string>("BridgeKusamaMessages", "OutboundMessages"), new System.Tuple<Substrate.NetApi.Model.Meta.Storage.Hasher[], System.Type, System.Type>(new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                            Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, typeof(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.MessageKey), typeof(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT17)));
        }
        
        /// <summary>
        /// >> PalletOwnerParams
        ///  Optional pallet owner.
        /// 
        ///  Pallet owner has a right to halt all pallet operations and then resume it. If it is
        ///  `None`, then there are no direct ways to halt/resume pallet operations, but other
        ///  runtime methods may still be used to do that (i.e. democracy::referendum to update halt
        ///  flag directly or call the `halt_operations`).
        /// </summary>
        public static string PalletOwnerParams()
        {
            return RequestGenerator.GetStorage("BridgeKusamaMessages", "PalletOwner", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> PalletOwnerDefault
        /// Default value as hex string
        /// </summary>
        public static string PalletOwnerDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> PalletOwner
        ///  Optional pallet owner.
        /// 
        ///  Pallet owner has a right to halt all pallet operations and then resume it. If it is
        ///  `None`, then there are no direct ways to halt/resume pallet operations, but other
        ///  runtime methods may still be used to do that (i.e. democracy::referendum to update halt
        ///  flag directly or call the `halt_operations`).
        /// </summary>
        public async Task<Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> PalletOwner(string blockhash, CancellationToken token)
        {
            string parameters = BridgeKusamaMessagesStorage.PalletOwnerParams();
            var result = await _client.GetStorageAsync<Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> PalletOperatingModeParams
        ///  The current operating mode of the pallet.
        /// 
        ///  Depending on the mode either all, some, or no transactions will be allowed.
        /// </summary>
        public static string PalletOperatingModeParams()
        {
            return RequestGenerator.GetStorage("BridgeKusamaMessages", "PalletOperatingMode", Substrate.NetApi.Model.Meta.Storage.Type.Plain);
        }
        
        /// <summary>
        /// >> PalletOperatingModeDefault
        /// Default value as hex string
        /// </summary>
        public static string PalletOperatingModeDefault()
        {
            return "0x0000";
        }
        
        /// <summary>
        /// >> PalletOperatingMode
        ///  The current operating mode of the pallet.
        /// 
        ///  Depending on the mode either all, some, or no transactions will be allowed.
        /// </summary>
        public async Task<Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.EnumMessagesOperatingMode> PalletOperatingMode(string blockhash, CancellationToken token)
        {
            string parameters = BridgeKusamaMessagesStorage.PalletOperatingModeParams();
            var result = await _client.GetStorageAsync<Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.EnumMessagesOperatingMode>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> InboundLanesParams
        ///  Map of lane id => inbound lane data.
        /// </summary>
        public static string InboundLanesParams(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.LaneId key)
        {
            return RequestGenerator.GetStorage("BridgeKusamaMessages", "InboundLanes", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> InboundLanesDefault
        /// Default value as hex string
        /// </summary>
        public static string InboundLanesDefault()
        {
            return "0x000000000000000000";
        }
        
        /// <summary>
        /// >> InboundLanes
        ///  Map of lane id => inbound lane data.
        /// </summary>
        public async Task<Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.InboundLaneData> InboundLanes(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.LaneId key, string blockhash, CancellationToken token)
        {
            string parameters = BridgeKusamaMessagesStorage.InboundLanesParams(key);
            var result = await _client.GetStorageAsync<Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.InboundLaneData>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> OutboundLanesParams
        ///  Map of lane id => outbound lane data.
        /// </summary>
        public static string OutboundLanesParams(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.LaneId key)
        {
            return RequestGenerator.GetStorage("BridgeKusamaMessages", "OutboundLanes", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> OutboundLanesDefault
        /// Default value as hex string
        /// </summary>
        public static string OutboundLanesDefault()
        {
            return "0x010000000000000000000000000000000000000000000000";
        }
        
        /// <summary>
        /// >> OutboundLanes
        ///  Map of lane id => outbound lane data.
        /// </summary>
        public async Task<Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.OutboundLaneData> OutboundLanes(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.LaneId key, string blockhash, CancellationToken token)
        {
            string parameters = BridgeKusamaMessagesStorage.OutboundLanesParams(key);
            var result = await _client.GetStorageAsync<Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.OutboundLaneData>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> OutboundLanesCongestedSignalsParams
        ///  Map of lane id => is congested signal sent. It is managed by the
        ///  `bridge_runtime_common::LocalXcmQueueManager`.
        /// 
        ///  **bridges-v1**: this map is a temporary hack and will be dropped in the `v2`. We can emulate
        ///  a storage map using `sp_io::unhashed` storage functions, but then benchmarks are not
        ///  accounting its `proof_size`, so it is missing from the final weights. So we need to make it
        ///  a map inside some pallet. We could use a simply value instead of map here, because
        ///  in `v1` we'll only have a single lane. But in the case of adding another lane before `v2`,
        ///  it'll be easier to deal with the isolated storage map instead.
        /// </summary>
        public static string OutboundLanesCongestedSignalsParams(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.LaneId key)
        {
            return RequestGenerator.GetStorage("BridgeKusamaMessages", "OutboundLanesCongestedSignals", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> OutboundLanesCongestedSignalsDefault
        /// Default value as hex string
        /// </summary>
        public static string OutboundLanesCongestedSignalsDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> OutboundLanesCongestedSignals
        ///  Map of lane id => is congested signal sent. It is managed by the
        ///  `bridge_runtime_common::LocalXcmQueueManager`.
        /// 
        ///  **bridges-v1**: this map is a temporary hack and will be dropped in the `v2`. We can emulate
        ///  a storage map using `sp_io::unhashed` storage functions, but then benchmarks are not
        ///  accounting its `proof_size`, so it is missing from the final weights. So we need to make it
        ///  a map inside some pallet. We could use a simply value instead of map here, because
        ///  in `v1` we'll only have a single lane. But in the case of adding another lane before `v2`,
        ///  it'll be easier to deal with the isolated storage map instead.
        /// </summary>
        public async Task<Substrate.NetApi.Model.Types.Primitive.Bool> OutboundLanesCongestedSignals(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.LaneId key, string blockhash, CancellationToken token)
        {
            string parameters = BridgeKusamaMessagesStorage.OutboundLanesCongestedSignalsParams(key);
            var result = await _client.GetStorageAsync<Substrate.NetApi.Model.Types.Primitive.Bool>(parameters, blockhash, token);
            return result;
        }
        
        /// <summary>
        /// >> OutboundMessagesParams
        ///  All queued outbound messages.
        /// </summary>
        public static string OutboundMessagesParams(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.MessageKey key)
        {
            return RequestGenerator.GetStorage("BridgeKusamaMessages", "OutboundMessages", Substrate.NetApi.Model.Meta.Storage.Type.Map, new Substrate.NetApi.Model.Meta.Storage.Hasher[] {
                        Substrate.NetApi.Model.Meta.Storage.Hasher.BlakeTwo128Concat}, new Substrate.NetApi.Model.Types.IType[] {
                        key});
        }
        
        /// <summary>
        /// >> OutboundMessagesDefault
        /// Default value as hex string
        /// </summary>
        public static string OutboundMessagesDefault()
        {
            return "0x00";
        }
        
        /// <summary>
        /// >> OutboundMessages
        ///  All queued outbound messages.
        /// </summary>
        public async Task<Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT17> OutboundMessages(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.MessageKey key, string blockhash, CancellationToken token)
        {
            string parameters = BridgeKusamaMessagesStorage.OutboundMessagesParams(key);
            var result = await _client.GetStorageAsync<Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bounded_collections.bounded_vec.BoundedVecT17>(parameters, blockhash, token);
            return result;
        }
    }
    
    /// <summary>
    /// >> BridgeKusamaMessagesCalls
    /// </summary>
    public sealed class BridgeKusamaMessagesCalls
    {
        
        /// <summary>
        /// >> set_owner
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetOwner(Substrate.NetApi.Model.Types.Base.BaseOpt<Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32> new_owner)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(new_owner.Encode());
            return new Method(53, "BridgeKusamaMessages", 0, "set_owner", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> set_operating_mode
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method SetOperatingMode(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.EnumMessagesOperatingMode operating_mode)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(operating_mode.Encode());
            return new Method(53, "BridgeKusamaMessages", 1, "set_operating_mode", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> receive_messages_proof
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ReceiveMessagesProof(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.sp_core.crypto.AccountId32 relayer_id_at_bridged_chain, Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bridge_runtime_common.messages.target.FromBridgedChainMessagesProof proof, Substrate.NetApi.Model.Types.Primitive.U32 messages_count, Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.sp_weights.weight_v2.Weight dispatch_weight)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(relayer_id_at_bridged_chain.Encode());
            byteArray.AddRange(proof.Encode());
            byteArray.AddRange(messages_count.Encode());
            byteArray.AddRange(dispatch_weight.Encode());
            return new Method(53, "BridgeKusamaMessages", 2, "receive_messages_proof", byteArray.ToArray());
        }
        
        /// <summary>
        /// >> receive_messages_delivery_proof
        /// Contains a variant per dispatchable extrinsic that this pallet has.
        /// </summary>
        public static Method ReceiveMessagesDeliveryProof(Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bridge_runtime_common.messages.source.FromBridgedChainMessagesDeliveryProof proof, Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Model.bp_messages.UnrewardedRelayersState relayers_state)
        {
            System.Collections.Generic.List<byte> byteArray = new List<byte>();
            byteArray.AddRange(proof.Encode());
            byteArray.AddRange(relayers_state.Encode());
            return new Method(53, "BridgeKusamaMessages", 3, "receive_messages_delivery_proof", byteArray.ToArray());
        }
    }
    
    /// <summary>
    /// >> BridgeKusamaMessagesConstants
    /// </summary>
    public sealed class BridgeKusamaMessagesConstants
    {
        
        /// <summary>
        /// >> BridgedChainId
        ///  Gets the chain id value from the instance.
        /// </summary>
        public Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Types.Base.Arr4U8 BridgedChainId()
        {
            var result = new Substrate.PolkadotBridgeHub.NET.NetApiExt.Generated.Types.Base.Arr4U8();
            result.Create("0x62686B73");
            return result;
        }
        
        /// <summary>
        /// >> MaximalOutboundPayloadSize
        ///  Maximal encoded size of the outbound payload.
        /// </summary>
        public Substrate.NetApi.Model.Types.Primitive.U32 MaximalOutboundPayloadSize()
        {
            var result = new Substrate.NetApi.Model.Types.Primitive.U32();
            result.Create("0x00002800");
            return result;
        }
    }
    
    /// <summary>
    /// >> BridgeKusamaMessagesErrors
    /// </summary>
    public enum BridgeKusamaMessagesErrors
    {
        
        /// <summary>
        /// >> NotOperatingNormally
        /// Pallet is not in Normal operating mode.
        /// </summary>
        NotOperatingNormally,
        
        /// <summary>
        /// >> InactiveOutboundLane
        /// The outbound lane is inactive.
        /// </summary>
        InactiveOutboundLane,
        
        /// <summary>
        /// >> MessageDispatchInactive
        /// The inbound message dispatcher is inactive.
        /// </summary>
        MessageDispatchInactive,
        
        /// <summary>
        /// >> MessageRejectedByChainVerifier
        /// Message has been treated as invalid by chain verifier.
        /// </summary>
        MessageRejectedByChainVerifier,
        
        /// <summary>
        /// >> MessageRejectedByPallet
        /// Message has been treated as invalid by the pallet logic.
        /// </summary>
        MessageRejectedByPallet,
        
        /// <summary>
        /// >> FailedToWithdrawMessageFee
        /// Submitter has failed to pay fee for delivering and dispatching messages.
        /// </summary>
        FailedToWithdrawMessageFee,
        
        /// <summary>
        /// >> TooManyMessagesInTheProof
        /// The transaction brings too many messages.
        /// </summary>
        TooManyMessagesInTheProof,
        
        /// <summary>
        /// >> InvalidMessagesProof
        /// Invalid messages has been submitted.
        /// </summary>
        InvalidMessagesProof,
        
        /// <summary>
        /// >> InvalidMessagesDeliveryProof
        /// Invalid messages delivery proof has been submitted.
        /// </summary>
        InvalidMessagesDeliveryProof,
        
        /// <summary>
        /// >> InvalidUnrewardedRelayersState
        /// The relayer has declared invalid unrewarded relayers state in the
        /// `receive_messages_delivery_proof` call.
        /// </summary>
        InvalidUnrewardedRelayersState,
        
        /// <summary>
        /// >> InsufficientDispatchWeight
        /// The cumulative dispatch weight, passed by relayer is not enough to cover dispatch
        /// of all bundled messages.
        /// </summary>
        InsufficientDispatchWeight,
        
        /// <summary>
        /// >> MessageIsNotYetSent
        /// The message someone is trying to work with (i.e. increase fee) is not yet sent.
        /// </summary>
        MessageIsNotYetSent,
        
        /// <summary>
        /// >> ReceivalConfirmation
        /// Error confirming messages receival.
        /// </summary>
        ReceivalConfirmation,
        
        /// <summary>
        /// >> BridgeModule
        /// Error generated by the `OwnedBridgeModule` trait.
        /// </summary>
        BridgeModule,
    }
}
